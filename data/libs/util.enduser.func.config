#!/usr/bin/env bash
cfg.edit() { #
#
#
	script_version=0.9.2
	script_created="2014.11.03"
	script_changed="2016.01.24"

	script_name="$FUNCNAME"
	script_title="$SWARM_MSG_CFG_EDIT_TITLE"
	script_header="$script_name ($script_version)"
#
#	Shared variables & Language
#
	swarm.protect "${@}" && exit 1
#
#	Variables
#
	if [[ -z "$1" ]]
	then	# Its empty...
		swarm.help.usage cfg.edit
		return 1
	else	# We got a valid argument:
		typeset -r CFG="$1"
	fi
	typeset -r LOG="$TUI_DIR_LOGS/${script_name}.log"
	declare TMP="${TUI_DIR_TEMP:-TMPDIR}/${script_name}-$$.tmp~"
	declare -A OPTIONS DEFAULTS INDEX TYPE LABELS
	declare -a FILES
	FILE_LABEL=""
	WAIT_SECONDS=1
	do_write_file=false
	do_hide_edit=false
	be_quiet=false
	be_clear=false
	>"$TMP"	# Clear content
#
#	Traps
#
	#trap "exit 130" INT ABRT KILL
	#trap "exit $?" QUIT
#
#	Messages to translate:
#
	MSG_TR_WORD_BACK="$SWARM_MSG_WORD_BACK"
	MSG_TR_WORD_EDIT="$SWARM_MSG_WORD_EDIT"
	MSG_TR_SELECT_FILE="$SWARM_MSG_PHRASE_SELECT_FILE"
	MSG_TR_CHANGE_VALUE="$SWARM_MSG_CFG_EDIT_SELECT_VAR"
	#MSG_TR_YY="$(eval_gettext '')"
#
#	Functions
#
	cfg.edit.cleanup() {
	# Removes all known tempfiles and exits
	# Is called at the end of the script and by the trap
		declare -a arr_CLEANUP=(
			"$TMP"
			# Add your tempfiles
			# here
			)
		for remove in "${arr_CLEANUP[@]}"
		do 	( [ -f "$remove" ] || [ -p "$remove" ] ) && rm -f "$remove"
		done
	}
	cfg.edit.edit_file() { # /path/to/FILE
	# Prints all variables and their values
	# Then lets user decide which variable to edit
		CONF="$1" ; shift
		MODE=input
		[ -n "$(builtin echo ${INDEX[@]})" ] && \
			OPTS_FOUND=("${INDEX[@]}") || \
			OPTS_FOUND=($(cfg.list "$CONF"))
		while 	# Preview
			#clear
			title "${FILE_LABEL:-$CONF}"
			for item in "${OPTS_FOUND[@]}" #$(cfg.list "$CONF")
			do 	printe  "$item" "$(cfg.get $CONF $item)" #>&1
			done
		# Select value or back
			title
			printe  "$MSG_TR_CHANGE_VALUE:"
			$do_hide_edit && this_edit="" || this_edit="$MSG_TR_WORD_EDIT"
			action=$(pick -m $this_edit "${OPTS_FOUND[@]}" || return 0)
		# Back or prepare variables
			[ ! "$MSG_TR_WORD_BACK" = "$action" ] || return 0
		do	# Edit
			if [ "$action" = "$this_edit" ]
			then	edit "$CONF"
				continue
			fi
		# Exit on cancel
			[ -z "${action/^[*}" ] && return 1
		# Print label
			printe #" --- $action  --- "
			LBL="${LABELS[$action]}"
			[ -n "$LBL" ] && status 111 "$LBL"
		# Get current values
			curval=$(cfg.get "$CONF" "$action")
			vTYP="${TYPE[$action]}"
		# Prepare the question, this one contains variables
			QUESTION="$SWARM_MSG_CFG_EDIT_VALUE_NEW: ${action}($curval)"
		# Prepare and execute according action
			[ -z "$vTYP" ] && vTYP=input
			case "$vTYP" in
			input)
				if ! newval=$(ask "$QUESTION")
				then	return 1
				fi
				;;
			select)
				printe  "$QUESTION"
				newval=$(pick ${OPTIONS[$action]}) || return 1
				;;
			esac

			if [ -z "$newval" ]
			then 	printf "\n"
				#return 1
			#	tui-yesno "$(eval_gettext 'Set $action to "$newval"?')" && \
			#		cfg.set -v "$CONF" "$action" "$newval"
			else 	cfg.set -v "$CONF" "$action" "$newval"
			fi
			$be_clear && wait "$WAIT_SECONDS" && clear && header "$script_header"
		done
	}
	cfg.edit.write_default() { # FILE
	# Writes the file if missing
	# and fills in all default values if missing
		if [ -z "$(echo ${INDEX[@]})" ]
		then	status 1 "$SWARM_MSG_CFG_EDIT_NO_OPTIONS"
			exit 1
		fi

		local thisConf="$1"
		[ -z "$thisConf" ] && \
			echo "$SWARM_MSG_CFG_EDIT_MUST_PROVIDE" && \
			return 1
		doOverwrite=false;if [ ! -f "$thisConf" ]; then touch "$thisConf" && doOverwrite=true|| return 1 ;fi
		$doOverwrite && cat "$TMP" > "$thisConf"
		for thisOpt in "${INDEX[@]}";do
			$GREP -q "$thisOpt" "$thisConf" || printf '%s\n' "${thisOpt}=${DEFAULTS[$thisOpt]}" >> "$thisConf"
		done
		$be_quiet && exit
	}
#
#	Traps are cool!
#
	# TRAP FUNCTION/"COMMAND" MODE's ...
	trap cfg.edit.cleanup INT QUIT KILL ABRT
#
#	Get options
#
	while :
	do 	#unset OPTS[@]
		case "$1" in
		-h|--help)	show_help	;;
		--version)	show_version	;;
		--)		shift ; break	;;
		# --------------------------------
		-H|--header)	script_header="$2"
				shift 2		;;
		-T|--title)	script_title="$2"
				shift 2		;;
		-F|--file)	FILE_LABEL="$2"
				shift 2		;;
		--conf-header)	cat >> "$TMP" <<-EOF
				# $2
				EOF
				shift 2 	;;
		--option)	INDEX["$2"]="$2"
				LASTOPT="$2"
				shift 2 	;;
		--default)	DEFAULTS[$LASTOPT]="$2"
				shift 2 	;;
		--values)	OPTIONS[$LASTOPT]="$2"
				TYPE[$LASTOPT]="select"
				shift 2 	;;
		--label)	LABELS[$LASTOPT]="$2"
				shift 2 	;;
		--write-no-exist)
				do_write_file=true
				shift		;;
		-q)		be_quiet=true
				shift 		;;
		-c)		be_clear=true
				shift 		;;
		--kiosk)	do_hide_edit=true
				shift		;;
		--wait|-w)	WAIT_SECONDS="$2"
				shift 2 	;;
		esac
		[ -z "$1" ] && LASTOPT=""
		((C++));[ $C -gt 100 ] && break
	done
	FILES=("${@}")
	[ ${#FILES[@]} -lt 1 ] && show_help
#
#	Action & Display
#
	$do_write_file && cfg.edit.write_default "$1"
	while 	header "$script_header" "" "$(date +'%F %T')"
		title "$script_title"
	do 	if [ ${#FILES[@]} -ne 1 ]
		then 	printe  "$MSG_TR_SELECT_FILE"
			thisFile=$(pick  "$MSG_TR_WORD_BACK" "${FILES[@]}")
			# This is a failsafe in case functions or variables gets listed...
			[ -f "$thisFile" ] || continue
		else	cfg.edit.edit_file "$FILES"
			RET=$?
			return $RET
		fi
		cfg.edit.edit_file "$FILES"
		RET=$?
		$be_clear && wait $WAIT_SECONDS && clear && header "$script_header"
	done
#
# 	Clean up & exit
#
	cfg.edit.cleanup
	return $RET
}
