#!/usr/bin/env bash
#
# Basic utility
#
	init.msg() { $PRINTF '%s\n' "$1" ;}
#
# First the most important basics
#
	if [[ -z "${UID:-${EUID}}" ]]
	then	# It's empty, lets get an id otherwise
			# This should fail actualy, but trying anyway.
			# I mean, it should never ever get to here....
			init.msg "$SWARM_MSG_INIT_NO_ID : uid=$UID euid=$EUID \nid=$(${ID:-\id})"
			UID=$(${ID:-\id -u})
			EUID=$(${ID:-\id -u})
	fi
#
# Finalize internal paths
#
	# Evalute home dir
	HOME="${HOME:-$(eval $ECHO ~$USER)}"
	# If its still empty, use 'cd' default behaviour to return to the users homedir if invoked without args
	[ -z "$HOME" ] && HOME=$(cd;$PWD_EXEC)
#
#   Make it work cross-plattform
#   You thought getting the SWARM dir was hard?
#   Have fun reading this! :p
#
	# Last attempt to check for missing '$HOME'
	if [[ -z "$HOME" ]]
	then	# HOME is empty, if UID is empty too, assume machine is still booting
		if [[ 0 -eq "${UID:-0}" ]]
		then	# Its 'root', check both even though /root is not standard and might not be available
			known="/root /usr/etc /etc /"
			for k in $($AWK  -v FS=":" '/^root/ {print $6}' /etc/passwd 2>/dev/zero) $known
			do 	[[ -d "$k" ]] && HOME="$k" && export HOME && break
			done
		else	# Its normal user
			known="/Users /home"
			for k in $known
			do 	[[ -d "$k" ]] && HOME="$k" && export HOME && break
			done
		fi
		[[ -z "$HOME" ]] && init.msg "$SWARM_MSG_INIT_HOME_NOT_FOUND : uid = $UID : $known"
	else
		# So, HOME is set, lets see if it exists
		if [[ -d "$HOME" ]]
		then	# It does exit, 'save' it
				export HOME
		else	# Nope, lets use fallback settings then...
				[[ -z "$SWARMRC" ]] && init.msg "$SWARM_MSG_INIT_HOME_NOT_FOUND"
				if [[ ! -z "$SWARMRC" ]]
				then	tmp_val=${SWARMRC##*/}
						HOME=${SWARMRC/$tmp_val}
						[[ ! -d "$HOME" ]] && \
							HOME="" && \
							init.msg "$SWARM_MSG_INIT_SWARMRC_PROV_NOT_FOUND" && \
							SWARMRC=""
				fi
				export HOME=${HOME:-$PWD}
		fi
	fi
	# Just in case this doesnt work, we could preset this variable
	# SWARMRC=../xy ./your-script.sh [args]
	SWARMRC=${SWARMRC:-$HOME/.swarmrc}
#
# Prepare LOG and TMP files
# Now that we have defind where one's $HOME is....
#
	if [[ 0 -eq ${UID:-${EUID:-0}} ]]
	then	# It's ROOT
			SWARM_LOG_DIR="/var/log"
			SWARM_TMP_DIR="/var/tmp"
	else	# It's a user, make sure we save to the right place
			declare tmp_worker
			tmp_worker="${XDG_CONFIG_DIR:-$HOME/.config}"
			SWARM_USER_CONFIG="$tmp_worker/swarm"
			# Not all mkdirs support creating subdirs...
			[[ -d "$tmp_worker" ]] || $MKDIR "$tmp_worker"
			[[ -d "$SWARM_USER_CONFIG" ]] || $MKDIR "$SWARM_USER_CONFIG"
			unset tmp_worker
			# Actualy set the required variables
			SWARM_LOG_DIR="${SWARM_USER_CONFIG}/logs"
			SWARM_TMP_DIR="${SWARM_USER_CONFIG}/tmp"
	fi
	for thisD in $SWARM_LOG_DIR $SWARM_TMP_DIR
	do
		[[ -d "$thisD" ]] || $MKDIR "$thisD"
	done
	SWARM_LOG="${SWARM_LOG_DIR}/all-swarm-internals.log"
	SWARM_TMP="${SWARM_TMP_DIR}/swarm-${SWARM_CODE}.tmp"
	# Finalize
	[[ ! -d "$SWARM_TMP_DIR" ]] && $MKDIR "$SWARM_TMP_DIR"
	#$TOUCH "$SWARM_TMP" ## No actual need to create an empty tempfile
#
# Prepare basic utility functions
#
	init.log() { ${isRO:-false} && return ; [ -f "$SWARM_LOG" ] || ( $TOUCH "$SWARM_LOG" && >"$SWARM_LOG") ; init.msg "$DATE_TIME_LOG SWARM :: $1" >> "$SWARM_LOG";}
	init.log.msg() { init.msg "$1"; ! ${isRO:-false} || init.log "$1";}
	init.log.check() {
	# Checks for log path and logfile
	# Creates if required and prints date and or divider line
		local RET
		if [[ ! -f "$SWARM_LOG" ]]
		then
			# Make sure path exists
			$MKDIR "$SWARM_LOG_DIR"
			! $TOUCH "$SWARM_LOG" && init.log.msg "${SWARM_MSG_INIT_LOG_FAIL} -> $SWARM_LOG @ uid:${UID:-$EUID}"
		fi
		# If todays date was not found, write it
		if $GREP "$DATE_TODAY" "$SWARM_LOG" >/dev/null
		then	# Print a visual divider
				init.log " -------------------"  #>> "$SWARM_LOG"
				RET=$?
		else	# Date is missing, print that instead
				init.log "$DATE_TODAY"
				RET=$?
		fi

		# Exit function
		return $RET
	}
#
# Make sure we can differ the date in the log,
# if this fails, no write access, RO?
#
	# Only check log if loging is enabled (default:true)
	${doLog:-true} && init.log.check && isRO=false || isRO=true
#
# Sometimes all that is needed,
# is a propper Clean Up
#
	swarm.cleanup() { #
	# Clears all known variables and sub routines on terminal exit from memory
	# This is for security and proper coding alike
		echo todo cleanup >&2
		unset ${!USER_*}

		for p in ${SWARM_PID_THEME}
		do
			kill -s SIGKILL $p
		done

		# Delete files
		[[ -f "$SWARM_TMP" ]] && $RM "$SWARM_TMP"

		# This as last for all the user display - and log - messages
		unset ${!SWARM_*}
		unset swarm.*
	}
#
#	Protection and Error handling
#
	break_on_injections() { # ARGS
	# Searches for injection subjects
	# Returns true if it finds some
		typeset arg ac=0
		for arg do
		ac="$((ac+=1))"
		case "$arg" in
		(*[';Â´|<&>']*|*':('*|*':-'*)
			printf "%s\n" "Aborting, injection detected! arg\${ac}='\$arg'"
			return 0
		;;
		esac
		done
		return 1
	}
	swarm.error() { # CALLER SCRIPT FUNCNAME LINENO [CONTENT]
		# Prints an error message and exits
		#
			caller="\$1" script="\$2" fname="\$3" lineno="\$4"
			shift 4 #2 #4

			content=($($ECHO "\${@}"))
			$PRINTF "\n"
			# The eval is required for the function to work after export
			eval $PRINTF '\t%s:\t%s\n' \\
				"Callerscript" "\$caller" \\
				"Scriptname" "\$script" \\
				"Functionname" "\$fname :: \$FUNCNAME" \\
				"Linenumber" "\$lineno :: \$LINENO"
			for cont in "\${content[@]}";do
				$PRINTF '\t* %s\n' "\$cont"
			done
			# Original
			#trap - HUP INT QUIT ABRT ALRM TERM EXIT
			# Neu
			swarm.cleanup
			traps_restore
			exit 1
		}
#
#	Traps & Error messages
#
	traps_save() { saved_traps="$(trap)" ; export saved_traps;}
	traps_restore() { eval \$saved_traps;}
	export -f traps_save traps_restore
	export -f swarm.error swarm.cleanup
	traps_save
	# Start my own traps....
	trap "swarm.error \${CALLER:-\$0} \$0 \$FUNCNAME \$LINENO '\$($ECHO -E \${@})'" ABRT ALRM QUIT TERM INT STOP HUP SEGV CONT PROF BUS SYS FPE
	trap "swarm.cleanup" ABRT QUIT TERM KILL HUP ALRM INT STOP EXIT
#
# Not all terminals support WIDTH and LINES....
#
	if [[ "x" == "x$WIDTH" ]] || [[ "x" == "x$LINES" ]]
	then	# Seems this terminal doesnt provide these variables...
			# Since it's 2020, lets do multi tasking this in the background!
		(
			while ${PS:-\ps} ${PPID:-$PID} | ${GREP:-\grep} ${PPID:-$PID} >> /dev/zero
			do
				export COLUMNS="$(eval $TPUT cols)"
				export LINES="$(eval $TPUT lines)"
				# If user wants extended logs, he shall have it
				$doLogExt && init.log "Updating geometrics for SWARM PID: ${PPID:-$PID}"
				# Using 15 secs for fallback mode
				sleep ${SWARM_INTERVALL_GEOMETRY:-15}
			done
		) & >> /dev/zero
		# Just in case..
		# We dont want 100 background process running...
		SWARM_PID_THEME="$SWARM_PID_THEME $!"
	fi
