#!/usr/bin/env bash
#
# Prepare some functions
#
	swarm.sanity.userconfig() { #
	# Make sure the basic user environment is ready
	#
		# Default value is failure
		local RET=1

		# First check wether the variable is not empty
		[[ -z "$SWARMRC" ]] && return $RET

		swarm.sanity.env

		swarm.sanity.userconfig.write
		RET=$?

		# Since $HOME should be checked by now,
		# lets hope we can rely on that for default dirs
		[[ ! -d "$HOME/.config" ]] && \
			$MKDIR "$HOME/.config" >>/dev/null
		[[ ! -d "$HOME/.config/swarm" ]] && \
			$MKDIR "$HOME/.config/swarm" >>/dev/null

		return $RET
	}
	swarm.sanity.userconfig.write() { #
	# Make sure there is a user config with valid information
	#
		# Try to get hostname
		HOST_NAME=${HOSTNAME:-$($HOSTNAME_EXEC)} >>/dev/null
		# If still empty
		HOST_NAME=${HOST_NAME:-localhost}
		# Try to get username
		USER=${USER:-${SUDO_USER:-${USER:-$($WHOAMI)}}} >>/dev/null
		# Special handling for root username display
		[[ "root" = "$USER" ]] && \
			USER_NAME=".·: ROOT :·." || \
			USER_NAME="$USER"
		USER_EMAIL="$USER @ $HOST_NAME"
		# Check for 'optional mandatories'
		MORELESS=""
		CURLWGET=""
		if [[ ! -z "$MORE$LESS" ]]
		then
				[[ -z "$MORE" ]] && \
					MORELESS=$LESS || \
					MORELESS=$MORE
		fi
		if [[ ! -z "$CURL$WGET" ]]
		then
				[[ -z "$WGET" ]] && \
					CURLWGET=$CURL || \
					CURLWGET=$WGET
		fi
		cat > $SWARMRC <<EOF
# Configuration file generated for SWARM (${SWARM[VERSION]} : ${SWARM[BUILD]})

# Leave empty to use SWARM that was provided with the script. HIGHLY RECOMENDED!
# If it contains a directory leading to SWARM, this version will be used, always!
# This might lead to version conflicts if you use scripts by different authors.
	SWARM_INSTALLED_DIR="$SWARM_DIR_INSTALLED"

# User Information
	USER_NAME="$USER_NAME"
	USER_EMAIL="$USER @ $HOST_NAME"
	USER_HOMEPAGE=""

# SWARM Settings
	SWARM_THEME=default-blue
	SWARM_USER_CONFIG="$SWARM_USER_CONFIG"
	SWARM_USER_LIBS="${SWARM_USER_CONFIG}/libs"

# SWARM Apps GUI
	EDITOR_GUI="${EDITOR_GUI}"
	WEB_GUI="$WEB_GUI"
	FILEMGR_GUI="$FILEMGR_GUI"
	TERMINAL_GUI="$TERMINAL_GUI"

# SWARM Apps CLI
	EDITOR_CLI="${EDITOR:-$EDITOR_CLI}"
	WEB_CLI="$WEB_CLI"
	FILEMGR_CLI="$FILEMGR_CLI"
	CURLWGET="$CURLWGET"
	MORELESS="${MORELESS}"

# SWARM Directories
	# Including SWARM_INSTALLED_DIR,
	# these are the only exceptions to the SWARM_DIR_* rule
	SWARM_LOG_DIR="$SWARM_LOG_DIR"
	SWARM_TMP_DIR="$SWARM_TMP_DIR"

	# These 2 are for performance boost as well
	# Do not change! Really, dont!
	SWARM_LOG="$SWARM_LOG"
	SWARM_TMP="$SWARM_TMP"


# For performance boost, this is required
# You can remove them if your system uses these variables anyway,
# otherwise SWARM might not work properly
	USER="$USER"
	HOME="$HOME"

# Core utils
# If you should encounter any loading issues of SWARM
# adjust the paths to the core utils here.
# -> If you have to preset the variable before source SWARM,
# -> please report so on GITHUB!
# Specialy SunOS/Solaris users might need to adjust AWK.
# Otherwise it is not recomended to change anything here,
# unless absolutly required.
EOF
		swarm.sanity.coreutils | $GREP -v HOSTNAME=  >> "$SWARMRC"
		return $?
	}
	swarm.sanity.coreutils() { #
	# Verfy all core utils work as expected
	#
		unset ${!tmp_*} #w W f F
		local list_cmd="echo printf awk grep sed su sudo ls mkdir rmdir rm tput which touch whoami pwd_exec hostname hostname_exec date more less sort"
		local worked=""
		local failed=""
		local f="" F="" w="" W=""

		# Fun question:
		WHICH=$(${WHICH:-\which} \which &2> /dev/null)

		# Let's see if that worked
		if [[ -f "${WHICH}" ]]
		then	# Ok, lets do it the easy way:
				for lc in $list_cmd
				do
					if ${WHICH} ${lc/_exec} >/dev/null &2>/dev/null &3>/dev/null
					then	worked="$lc $worked"
					else	failed="$lc $failed"
					fi
				done
				# Check for optional mandatories ; set variables with 'which'
				export CURL=$(${WHICH} curl &2> /dev/null)
				export WGET=$(${WHICH} wget &2> /dev/null)
				export MORE=$(${WHICH} more &2> /dev/null)
				export LESS=$(${WHICH} less &2> /dev/null)
		else	# Ok, the slightly more complicated way
				for lc in $list_cmd
				do
					tmp_exe=${lc^^}
					tmp_exec2=${!tmp_exe}
					if $(eval ${tmp_exec2} --help &>> /dev/null )  &>> /dev/null
					then
							worked="$worked $lc"
					else
							# Handle possible exceptions
							case "$tmp_exe" in
							"PWD")
									[[ -d  "${tmp_exec2}" ]] && \
										worked="$worked $lc" || \
										failed="$failed $lc"	;;
							"CURL"|"WGET")
									[[ -d  "${tmp_exec2}" ]] && \
										worked="$worked $lc" 	;;
							"PWD_EXEC")
									tmp_val="$(eval ${tmp_exec2} --help 2&>> /dev/null )"  &>> /dev/null && \
										worked="$worked $lc" || \
										failed="$failed $lc"   ;;

							"ECHO")
									tmp_val=${tmp_exec2:-\printf}
									if [[ "xx" ==  "$($tmp_val xx)" ]]
									then
										export ECHO=$tmp_val
										worked="$worked $lc"
									else
										failed="$failed $lc"
										# List it as failed since ECHO doesnt exist,
										# but use this code as fallback
										export ECHO="\printf '$1\n'"
									fi   ;;
							"PRINTF")
									tmp_val="$(eval ${tmp_exec2} --help &>> /dev/null )"  &>> /dev/null
									[[ $? == 2 ]] && \
											worked="$worked $lc" || \
											failed="$failed $lc"   ;;
							"TPUT")
									tmp_val="$(eval ${tmp_exec2} --help &>> /dev/null )"  &>> /dev/null
									[[ $? == 2 ]] && \
											worked="$worked $lc" || \
											failed="$failed $lc"   ;;
							"HOSTNAME")
									[[ "$HOSTNAME" == "$(\hostname)" ]] && \
											worked="$worked $lc" || \
											failed="$failed $lc"   ;;
							"HOSTNAME_EXEC")
									[[ "$HOSTNAME" == "${tmp_exec2}" ]] && \
											worked="$worked $lc" || \
											failed="$failed $lc"   ;;
							# If this was installed, we'd be doing the easy way.
							#"WHICH")
							#		set -x
							#		eval ${tmp_exec2} --help &>> /dev/null  &>> /dev/null
							#		[[ $? == 0 ]] && \
							#				worked="$worked $lc" || \
							#				failed="$failed $lc"   ;;
							*)	  init.log "${SWARM_MSG_INIT_SANITY_UNKOWN_CASE} $lc : $tmp_exe : $tmp_exec2"
									failed="$failed $lc"					;;
							esac
					fi
				done
		fi

		for w in $worked
		do
			local W=${w^^}
			#[[ $W = "WHICH" ]] && echo " ------------- ANFANG " && set -x
			$PRINTF '\t%s\n' "$W=\\${!W}" | $SED s,'HOSTNAME=\\','HOSTNAME=',g | $SED s,*'=\\','',g  >&1
			#[[ $W = "WHICH" ]] & set +x
		done

		for f in $failed
		do
			[ -z "$f" ] && break
			F=${f^^}
			init.log.msg "$SWARM_MSG_STR_FAILED: \t$F=${!F}" >&2
		done

		# Abort if something failed
		[[ ! -z "${failed}" ]] &&  return 1
		# All good
		return 0
	}
	cfg.list() { # FLIE
	# Parses given FILE for non commented lines
	# and returns what is on the 'variabel' side of '='
		[[ -z "$1" ]] && $PRINTF '%s\n' "${SWARM_MSG_CFG_LIST}" && return 1
		$GREP -v ^"#" "$1"|$GREP "="|$SED s,"="," ",g|$AWK '{print $1}'
	}
	cfg.get() { # FILE VARNAME
	# Gets the value of VARNAME from given FILE
	# Returns empty with code 1 if nothing was found
		[[ -z "$2" ]] && $PRINTF '%s\n' "${SWARM_MSG_CFG_GET}" && return 1
		local CONFFILE="$1"
		local VARNAME="$2"
		[ ! -f "$CONFFILE" ]  && $PRINTF '%s\n' "$SWARM_MSG_STR_FILE_NOT_FOUND" >&2 && return 1
		[ "$CONFFILE" = "${CONFFILE##*/}" ] && CONFFILE="./$CONFFILE"

		# If VARNAME starts with Pass|password|pw, do not source the conf file but use awk
		case "${VARNAME,,}" in
		pw|pass|passwor[dt])
			beSecure=true
			;;
		esac
	#
	#	Display
	#
		if $beSecure
		then	# This is slower but doesnt show up the other values
			$AWK -F= -v VAR="$VARNAME" '$1 ~ "^[^#]*" VAR "$"{gsub ("#.*$|\"|\047|"$1 FS, ""); print}' "$CONFFILE" | tail -n1
		else	# This method is about twice the speed of the awk
				# But alot less secure
			source "$CONFFILE" && $PRINTF "${!VARNAME}"
		fi
	}
	cfg.set() { # FLIE VARNAME VALUE
	# Sets the value of VARNAME from given FILE to VALUE
	# Returns with code 0 on success and code 1 if failed
		[[ -z "$3" ]] && $PRINTF '%s\n' "${SWARM_MSG_CFG_SET}" && return 1
		echo "TODO $FUNCNAME"
	}
	swarm.sanity.env() { #
	#
	#
		$PRINTF '\n%s\n' "TODO : $FUNCNAME"
		#echo " ----------------------------"
		#header 	"SWARM ${SWARM[VERSION]}" " " "$DATE_TODAY : $DATE_TIME"
		#title	"Initial Sanity Check"
		#printe TODO "locate find"
		local tmp=""

		for task in editor filemgr terminal web
		do	# These are filenames to parse
			for mode in cli gui
			do	# For these modes to be in
					tmp="${SWARM_DIR_DATA}/lists/${task}_${mode}"
					if [[ -f "$tmp" ]]
					then	# It's everything but terminals
							while read app
							do
								if [[ -f "$WHICH" ]]
								then	# clear it
										app_found=""
										# Set new
										app_found=$(${WHICH} $app &2>/dev/zero ) >/dev/zero &2>/dev/zero
										[[ ! -z "$app_found" ]]  && \
											eval export "${task^^}_${mode^^}=$app_found"

								else	$app --help &2>>/dev/zero >/dev/zero
										echo $?
								fi
							done<${tmp}

					else	# It's probably terminals or god behave, an error
							echo
					fi
			done
		done
		echo " ------------"
		#set -x
		cfg.set "$SWARMRC" "EDITOR_CLI" "$EDITOR_CLI"
		#set +x
		echo " --------------"
	}
	#swarm.sanity.env
	# Simple echo's, by RudiC @ unix.com
	echo_(){
	  ( IFS=" "; printf "%s\n" "$*" )
	}
	# Portable echo -n
	echo_n() {
	  ( IFS=" "; printf "%s" "$*" )
	}
	# Portable echo -e
	echo_e() {
	  ( IFS=" "; printf "%b\n" "$*" )
	}
	# Portable echo -ne
	echo_ne() {
	  ( IFS=" "; printf "%b" "$*" )
	}
	alias echo_en=echo_ne
#
# Lets check if environment is 'sane'
#
#
# This is checked only the first time

if $isSWARMfirstTime && swarm.sanity.userconfig
then	# SWARMRC was written successfull and it is the first time running
		[[ -f "$SWARMRC" ]] && \
			source "$SWARMRC" && \
			isSourced=true
fi
