#!/usr/bin/env bash
#
# Prepare functions
# to display functions to End User (hence: eu) :P
# Please see: ./docs/{MANUAL,SYNTAX}.md) for further information
#
	swarm.eu.function.list() { # [FILE]
	# Prints a list of properly declared functions
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		local tmp_list=""
		local tmp_oldpwd="${PWD:-$($PWD_EXEC)}"

		if [[ -n "$1" ]] && [[ -f "$1" ]]
		then	# There is a specific file passed to parse
				cd "$SWARM_DIR_LIBS"
				$GREP "() { #" "$1"| \
					$GREP -v GREP | \
					$AWK -v FS='() ' '{print $1}' | \
					$SED s,'()','',g
				cd "$tmp_oldpwd"
		else	# Just parse all files in SWARM_DIR_LIBS
				raw_output() {
					(
						cd "$SWARM_DIR_LIBS"
						$GREP init.*"() {" * | $GREP -v GREP
						$GREP cfg.*"() {" * | $GREP -v GREP
						$GREP swarm.*"() {" * | $GREP -v GREP
						cd "$tmp_oldpwd"
					) | while IFS=": " read one two three
					do
						# The IFS takes care of the GREP filenames
						# and this variable-regex takes care of the function definition
						echo "${two/()}"
					done
				}
				# Show data
				raw_output | sort -u
				unset -f raw_output
		fi
	}
	swarm.eu.function.show() { # MODE [FILE] FUNCTIONNAME		## MODE= --text || --code
	# Prints either these 2 comment lines or the code
	# Please see: ./docs/{MANUAL,SYNTAX}.md)
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#
		# Vars
		#
			local tmp_oldpwd="${PWD:-$($PWD_EXEC)}"
			local GREP_OPTS=""
		#
		# Check for args
		#
			local MODE=none
			case "$1" in
				"--text")
					MODE=text
					shift
					;;
				"--code")
					MODE=code
					shift
					;;
				*)
					MODE=text
					#return 1
					;;
			esac
			[[ -f "$1" ]] && \
				local curFILE="$1" && shift || \
				local curFILE=""
		#
		# Code
		#
			# Prepare command
			case "$MODE" in
				"text")
					GREP_OPTS="-h -a2  ${1}"
					cd "$SWARM_DIR_LIBS"
					# This is just to reduce unrequired disk usage
					[[ -n "$curFILE" ]] && \
						$GREP $GREP_OPTS "$curFILE"|| \
						$GREP $GREP_OPTS *
					cd "$tmp_oldpwd"
					;;
				"code")
					type "$1"
					;;
			esac
	}
	swarm.eu.show.basics() { #
	#
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		echo
		echo "Funcname: $FUNCNAME"
		echo
		local list="$(swarm.eu.function.list ${SWARM_DIR_LIBS}/util.enduser)"
		echo $list
		header 	--default
		title 	"my test"

		swarm.eu.function.list ${SWARM_DIR_LIBS}/util.enduser| \
			while read line
			do
				curSTR=""
				curSTR="$(swarm.eu.function.show --text ${SWARM_DIR_LIBS}/util.enduser $line)"
				printe "$line"		"${curSTR/\n*}"
			done
		status $? "Yeehaa!"
		return 0

		for entry in $list
		do	# Now print each entry and get it's description
			# This is also a great option to test
			printe "$entry"		"$(swarm.eu.function.show --text ${SWARM_DIR_LIBS}/util.enduser) $entry)"
		done
		status $? "Yeehaa!"
	}
	swarm.eu.help.menu() { # [ITEM]
	# Prints help to ITEM and returns with 1
	# Prints help menu if no ITEM is passed and returns with 0
		local item=""
		list_func_basic="header title printe status yesno pick input cfg.list cfg.get cfg.set cfg.menu"
		list_func_adv="printlist swarm.str*"
		list_func_int=""
		#[[ -z "$1" ]]
		while [[ -z "$item" ]] # [[ "$item" != "${SWARM_MSG_STATUS_BACK}" ]]
		do
			clear
			header --default
			title "${SWARM_MSG_HELP_EU_HELP_MENU_TITLE}"
			printe "${SWARM_MSG_HELP_EU_HELP_MENU_TEXT1}"
			item="$(pick -m $(swarm.eu.function.list))" || item=""
			case "$item" in
			"${SWARM_MSG_STATUS_BACK}")
				return 0
				;;
			*)
				$PRINTF '\r%s\n' "${item}" #=$(pick $list_func_basic)
				
				;;
			esac
			
		done
	}
