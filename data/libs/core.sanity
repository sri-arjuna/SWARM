#!/usr/bin/env bash
#
# 	swarm.sanity.sys.env
#			curlwget
#			moreless
#			sudoer
#			hostname
#			apps
#	swarm.sanity.userconfig.apps
#				
#
# Prepare some functions
#
	swarm.sanity.userconfig.write() { #
	# Write the user configuration / SWARMRC
	#

		cat > "$SWARMRC" <<EOF
#!/usr/bin/env bash
# Configuration file generated for SWARM (${SWARM[VERSION]} / Build: ${SWARM[BUILD]})

# Leave empty to use SWARM that was provided with the script. HIGHLY RECOMENDED!
# If it contains a directory leading to SWARM, this version will be used, always!
# This might lead to version conflicts if you use scripts by different authors.
	SWARM_INSTALLED_DIR="$SWARM_DIR_INSTALLED"

# User Information
	USER_NAME="$USER_NAME"
	USER_EMAIL="$USER @ $HOST_NAME"
	USER_HOMEPAGE=""

# SWARM Settings
	SWARM_THEME=default-blue
	SWARM_USER_CONFIG_DIR="$SWARM_USER_CONFIG_DIR"
	SWARM_USER_LIBS="${SWARM_USER_CONFIG_DIR}/libs"
	SWARM_USER_SCRIPTS="$HOME/bin"

# SWARM Apps GUI
	EDITOR_GUI="${EDITOR_GUI}"
	WEB_GUI="$WEB_GUI"
	FILEMGR_GUI="$FILEMGR_GUI"
	TERMINAL_GUI="$TERMINAL_GUI"

# SWARM Apps CLI
	EDITOR_CLI="${EDITOR:-$EDITOR_CLI}"
	WEB_CLI="$WEB_CLI"
	FILEMGR_CLI="$FILEMGR_CLI"
	CURLWGET="${CURLWGET}"
	MORELESS="${MORELESS}"

# SWARM Directories
	# Including SWARM_INSTALLED_DIR,
	# these are the only exceptions to the SWARM_DIR_* rule
	SWARM_LOG_DIR="$SWARM_LOG_DIR"
	SWARM_TMP_DIR="$SWARM_TMP_DIR"

	# Feel free to move or rename the logfile
	SWARM_LOG="$SWARM_LOG"


# Core utils
# If you should encounter any loading issues of SWARM
# adjust the paths to the core utils here.
# -> If you have to preset the variable before source SWARM,
# -> please report so on GITHUB!
# SunOS/Solaris users might need to adjust AWK.
# Otherwise it is not recomended to change anything here,
# unless absolutly required.
	PRINTF="${PRINTF:-\printf}"
	ECHO="${ECHO:-\printf}"
	AWK="${AWK:-\gawk}"
	GREP="${GREP:-\grep}"
	SED="${SED:-\sed}"
	PWD_EXEC="${PWD_EXEC:-\pwd}"
	DATE="${DATE:-\date}"
	MKDIR="${MKDIR:-\mkdir}"
	TOUCH="${TOUCH:-\touch}"
	PWD_EXEC="${PWD_EXEC:-\pwd}"
	TPUT="${TPUT:-\tput}"
	WHICH="${WHICH}"
	
	SU="${SU:-\su}"
	SUDO="${SUDO:-\sudo}"
	ID="${ID:-\id}"
	WHOAMI="${WHOAMI:-\whoami}"
	SORT="${SORT:-\sort}"
	LS="${LS:-\ls}"
	RM="${RM:-\rm}"
	RMDIR="${RMDIR:-\rmdir}"
	FIND="${FIND:-\find}"
EOF
		#swarm.sanity.coreutils | $GREP -v HOSTNAME=  >> "$SWARMRC"
		$SED -i s,"${SWARM_USER_CONFIG_DIR}/","\${SWARM_USER_CONFIG_DIR}/",g "$SWARMRC"
		$SED -i s,"${SWARM_USER_CONFIG_DIR}/log/","\${SWARM_LOG_DIR}/",g "$SWARMRC" 
		$SED -i s,"${SWARM_USER_CONFIG_DIR}/tmp/","\${SWARM_TMP_DIR}/",g  "$SWARMRC"
		$SED -i s,"\${SWARM_USER_CONFIG_DIR}/log/","\${SWARM_LOG_DIR}/",g  "$SWARMRC"
		$SED -i s,"${HOME}/","\${HOME}/",g  "$SWARMRC"
		return $?
	}
	swarm.sanity.env.coreutils() { #
	# Verfy all core utils work as expected
	#
		unset ${!tmp_*}
		local list_cmd="echo printf awk grep sed su sudo ls mkdir rmdir rm tput which touch whoami pwd_exec hostname hostname_exec date more less sort curl wget"
		local worked=""
		local failed=""
		local f=""
		local F=""
		local w=""
		local W=""

		# Fun question:
		# Use internal which function if which is not installed
		$hasWhich && \
			export WHICH=$(${WHICH:-\which} \which &2> /dev/null) || \
			export WHICH="swarm.util.which"
		
		# Lets do it the easy way:
		for lc in $list_cmd
		do
			if tmp_=$( ${WHICH} ${lc/_exec}) >/dev/null &2>/dev/null &3>/dev/null
			then	worked="$tmp_ $worked"
				#echo " ..... ------------------------ "
			else	failed="$lc $failed"
			fi
		done
		

		for w in $worked
		do
			local W=${w^^}
			#[[ $W = "WHICH" ]] && echo " ------------- ANFANG " && set -x
			$PRINTF '\t%s\n' "$W=${!W}" | $SED s,'HOSTNAME=\\','HOSTNAME=',g | $SED s,*'=\\','',g  >&1
			#[[ $W = "WHICH" ]] & set +x
		done

		for f in $failed
		do
			[ -z "$f" ] && break
			F=${f^^}
			init.log.msg "$SWARM_MSG_STR_FAILED: \t$F=${!F}" >&2
		done

		# Abort if something failed
		[[ -n "${failed}" ]] && \
			init.log.msg "Failed: $failed" && \
			return 1
		# All good
		return 0
	}
	cfg.list() { # FLIE
	# Parses given FILE for non commented lines
	# and returns what is on the 'variabel' side of '='
		[[ -z "$1" ]] && $PRINTF '%s\n' "${SWARM_MSG_CFG_LIST}" && return 1
		$GREP -v ^"#" "$1"|$GREP "="|$SED s,"="," ",g|$AWK '{print $1}'
	}
	cfg.get() { # FILE VARNAME
	# Gets the value of VARNAME from given FILE
	# Returns empty with code 1 if nothing was found
		[[ -z "$2" ]] && $PRINTF '%s\n' "${SWARM_MSG_CFG_GET}" && return 1
		local CONFFILE="$1"
		local VARNAME="$2"
		[ ! -f "$CONFFILE" ]  && $PRINTF '%s\n' "$SWARM_MSG_STR_FILE_NOT_FOUND" >&2 && return 1
		[ "$CONFFILE" = "${CONFFILE##*/}" ] && CONFFILE="./$CONFFILE"

		# If VARNAME starts with Pass|password|pw, do not source the conf file but use awk
		case "${VARNAME,,}" in
		pw|pass|passwor[dt])
			local beSecure=true
			;;
		esac
	#
	#	Display
	#
		if $beSecure
		then	# This is slower but doesnt show up the other values
			$AWK -F= -v VAR="$VARNAME" '$1 ~ "^[^#]*" VAR "$"{gsub ("#.*$|\"|\047|"$1 FS, ""); print}' "$CONFFILE" | tail -n1
		else	# This method is about twice the speed of the awk
			# But alot less secure
			source "$CONFFILE" && $PRINTF "${!VARNAME}"
		fi
	}
	cfg.set() { # FLIE VARNAME VALUE
	# Sets the value of VARNAME from given FILE to VALUE
	# Returns with code 0 on success and code 1 if failed
		[[ -z "$3" ]] && $PRINTF '%s\n' "${SWARM_MSG_CFG_SET}" && return 1
		echo "TODO $FUNCNAME"
	}
	swarm.sanity.env() { #
	# Some basic internal variables
	# HOST_NAME, USER_NAME, USER_EMAIL, MORELESS and CURLWGET
		# Try to get hostname
		HOST_NAME=${HOSTNAME:-$($HOSTNAME_EXEC)} >>/dev/null
		# If still empty
		export HOST_NAME=${HOST_NAME:-localhost}
		# Try to get username
		export USER=${USER:-${SUDO_USER:-${USER:-$($WHOAMI)}}} >>/dev/null
		# Special handling for root username display
		$isRoot && \
			export USER_NAME=".·: ROOT :·." || \
			export USER_NAME="$USER"
		export USER_EMAIL="$USER @ $HOST_NAME"
	#
	# Check for 'optional mandatories'
	#
		# Clear handler Variables
		MORELESS=""
		CURLWGET=""
		# Check individual vars
		set -x
		MORE=$(swarm.util.which "${MORE:-more}")
		LESS=$(swarm.util.which "${LESS:-less}")
		CURL=$(swarm.util.which "${CURL:-curl}")
		WGET=$(swarm.util.which "${WGET:-wget}")
		set +x
		if [[ -n "$MORE$LESS" ]]
		then
			[[ -z "$MORE" ]] && \
				export MORELESS="$LESS" || \
				export MORELESS="$MORE"
		else
			# Neiter MORE nor LESS is installed
			# Lets hope PAGER is set to someting working...
			# Otherwise, use CAT as fallback... 
			init.log.msg "$SWARM_MSG_INIT_MORELESS_NFOUND"
			export MORELESS=${PAGER:-\cat}
		fi
		# Either curl or wget was sound
		if [[ -n "$CURL$WGET" ]]
		then
			# Use curl as main app
			# use wget only if curl does not exist
			[[ -z "$CURL" ]] && \
				export CURLWGET="$WGET" || \
				export CURLWGET="$CURL"
		else	init.log.msg "$SWARM_MSG_INIT_CURLWGET_NFOUND"
		fi
	}

#
# This is checked only the first time
#
	if [[ ! -f "$SWARMRC" ]] #& swarm.sanity.userconfig
	then	
		swarm.sanity.env
		#swarm.sanity.env.apps
		swarm.sanity.env.coreutils
		swarm.sanity.userconfig.write
	fi
