#!/usr/bin/env bash
#
#	SWARM is the successor of TUI (Text User Interace)
#	It is an interface between script authors and end users.
#	In doing so, the scripts you write,
#	will appear application-like to an end user.
#
#	This file is to be called from your script like eiter one of:
#	source ./runtime
#	source ./SWARM/runtime
#
#	To get started writing scripts, call this file like eiter one of:
#	./runtime help
#	./runtime manual
#	./runtime docs
#
#	To change settings, you can use eiter one of:
#	./runtime config
#	swarm.userconfig.edit
#	edit "$HOME/.swarmrc" "$HOME/.config/swarm/"
#
##############################################
# Requirements:
# * BASH 4.3+
# * GNU Coreutils 8.25
# *
#
# Speed increase:
# * Make sure '$HOME' is set and exists for all shell login accounts.
# * Preset SWARMDIR=/path/to/SWARM
#
# RAMDISK
# As root you can force the use of a RAMDISK
# for configuration, log- and possible tempfiles.
# If you should enounter a R(ead)O(nly)-system, logs and
# config files will be disabled, unless you:
# * Preset SWARM_RAMDISK=true
# * Optionaly, you may pass SWARM_RAMDISK_DIR=/path/to/mountpoint
##############################################
#
# Clear certain env and other variables
#
	${DEBUG:-false} && set -x
	# shellcheck disable=SC2086,SC2184
	unset SWARM[@] ${!SWARM_DIR_*} IFS >/dev/zero
	declare -A SWARM
#
#	    ---   Datasheet   ---
#
#################################################
# SWARM = Shell Wrapper and Runtime Modifier	#
# Author:	Simon Arjuna Erat (sea)		#
SWARM[LICENSE]="GPLv2"	# License: ./docs/GPLv2	#
# Idea:		1995				#
# Copyleft:	2011-2021			#
# Created:	2020.01.18			#
# Changed:	2021.06.28	 		#
SWARM[VERSION]=0.9
SWARM[BUILD]=69
SWARM[GIT]="http://github.com/sri-arjuna/SWARM"
SWARM[ISSUES]="${SWARM[GIT]}/issues"
#################################################
#
# Version Check
#
	if [[ -z ${BASH_VERSINFO[@]} ]] || [[ ${BASH_VERSINFO[0]} -lt 4  ]]
	then	# Print error if no BASH variables were found
		# Or if BASH version is too low
		printf '%s\n' "Requires BASH 4.3 or higher"
		return 2>/dev/zero || exit
	else	# Bash version seems is 4 or higher
		if [[ 4 -eq ${BASH_VERSINFO[0]} ]]
		then 	# Major matches
			if [[ ${BASH_VERSINFO[1]} -lt 3  ]]
			then	# Minor does not
				printf '%s\n' "Requires BASH 4.3 or higher"
				# At least that is where I can guarantue it works as promised.
				return 2>/dev/zero || exit
			fi
		fi
	fi
#
# Core Public Variables
#
	# This is default 'highlighted' MACHINE or ROOT display
	# Non-root users (if existing) have very hardcoded 'default-blue' (fallback) theme
	SWARM[THEME]="default-red"
	# This refers to the location of this file
	# You can spee up the process by passing: SWARMDIR=
	SWARM[ROOTDIR]="$SWARMDIR"
	# Language must be pre-set up until the basic language file was loaded
	SWARM[LANG]="en_GB"
	SWARM_CODE=$$
	# isSWARMfirstTime will be set to false if SWARMRC (~/.swarmrc) is found
	isSWARMfirstTime=true

#
# Cross Platform Compatibility (CPC)
#
# There are hints on:
# * https://community.unix.com/t/tip-template-for-a-safe-and-portable-script/375171
# But I'm ignoring  the recomended language setting, since SWARM scripts do support different languages,
# and does already a specific LC_ALL=C before 'system' calls it parses.
	# Exporting an empty variable, but if it is, it will be filled with the current path. (they are mis-spelled on purpose!)
	# This is used in swarm.cleanup to restore the env if this file was sourced
	# Lets add an appending : so we restore to a non-path env as (if) it were
	PATH_ORGINAL="${PATH_ORGINAL:-$PATH:}"
	PWD_ORGINAL=="${PWD_ORGINAL:-${PWD:-$(pwd)}}"
	# HP-UX is Posix-compliant with
	export UNIX95=
	# GREP_OPTIONS can obscure GNU grep
	unset GREP_OPTIONS
	# LD_* can obscure external commands
	unset LD_LIBRARY_PATH LD_PRELOAD
	# no glob file-matching in command args and word lists (for loop)
#	set -f
	# Unix optional packages install in
	opt_path="/usr/local/bin:/usr/local/sbin"
	solaris_opt_path="/usr/sfw/bin:/opt/csw/bin"
	# Catch if we are 'within' a 'configure' env
	[[ -n "$BINDIR$SBINDIR"  ]] && configure_PATH="$BINDIR:$SBINDIR"
	# Catch other seen variables...
	[[ -n "$OS_DIR_BIN$OS_DIR_SBIN"  ]] && os_PATH=":$OS_DIR_BIN:$OS_DIR_SBIN"
	# These are the most basic places to look for executables
	# Since the usr-move, it is prefered to first look for those directories
	posix_PATH="/usr/bin:/usr/sbin:/bin:/sbin"
	# Create a new PATH based on existing templates
	path_new="/usr/xpg4/bin:/usr/ucb"
	# After all, users might have taken their time to provide required/desired path attributes to their ENV..
	# Lets make sure they do not get forgotton, just handle those as last... ;)
	for elem in $(sed s,":","\n",g -- <<< "${posix_PATH}:${opt_path}:${configure_PATH}:${os_PATH}:${PATH}" )
	do
		[[ :"$path_new": != *:"$elem":* ]] && \
			path_new+=":$elem"
	done
	# set PATH so no PATH is inherited, export it to all children
	PATH="$path_new" ; unset path_new
	export PATH
	# Check if we need special treatment
	[[ -n "$SSH_CLIENT" ]] && isSSH=true || isSSH=false
	# Make sure TERM is set
	TERM="${TERM:-GNU_Linux}"
	# Check if it were empty or even worse, if we are in a 'dumb' TERM...
	# And of course, if we idenfity ourself already as SSH_Client, then of course we have to go there!
	if [[ "dumb" == "${TERM}" ]] || [[ "" == "${TERM/GNU_Linux}" ]] || $isSSH
	then	# Lets fix term to something useful
		TERM="xterm"
		# This is required to work within a SSH env
		export TERM
		# If there were another reason we have a restricted session
		# Lets just reuse this for the same purpose - for now... (because its the only reason I know of!)
		isSSH=true
		# Skip selection if COLUMNS are preset
		if [[ -z "$COLUMNS" ]]
		then	# TODO:: check without this block
			echo "How many COLUMNS (width) does your terminal have?"
			select COLUMNS in 60 70 80 90 100 110 120 150 200 239;do break;done
			export COLUMNS
		fi
	fi
	# This is to avoid 80 COlUMNS screens in a ssh -T session while the screen is a 190 COLUMNS window.
	# hasCOLUMNS is for internal use only
	if [[ -n "$COLUMNS" ]]
	then	# We want this to applied even - well specialy - within a SSH env
		# because if the SSH terminal requires us to set a specific width
		# - there wont be a way to idenfity the proper width of the screen/tty.
		hasCOLUMNS=true
	else	# This is still required, So swarm.update.geometry will update the value
		# to adjust to terminal window changes - that otherwise (hasColumns=true)
		# would happen automatically, or be forced to a specific width
		hasCOLUMNS=false
		# This is now invoked for a first value
		# swarm.update.geometry will update this value every given intervall automatically
		COLUMNS=$(tput cols)
	fi
	# Most basic commands ; do not change (But pre-set these variables in the shell for first use)!
	# This WILL be overwritten by the SWARMRC (~/.swarmrc)
	export ECHO="${ECHO:-echo}"
	export PRINTF="${PRINTF:-printf}"
	export AWK=${AWK:-\gawk}
	export GREP=${GREP:-\grep}
	export SED=${SED:-\sed}
	export LS=${LS:-\ls}
	export PWD_EXEC=${PWD_EXEC:-\pwd}
	export DATE=${DATE:-\date}
	export TOUCH=${TOUCH:-\touch}
	export PWD_EXEC=${PWD_EXEC:-\pwd}
	export TPUT="${TPUT:-tput}"
	# SU and SUDO must be empty if the command was not found
	# They are assigned now however, to 'overwrite' their location
	export SU=${SU}
	export SUDO=${SUDO}
	export ID=${ID:-\id}
	export WHOAMI=${WHOAMI:-\whoami}
	export SORT=${SORT:-\sort}		# NOT a GNU coreutil
	export LS=${LS:-\ls}
	export RM=${RM:-\rm}
	export RMDIR=${RMDIR:-\rmdir}
	export FIND=${FIND:-\find}
	export TR=${TR:-\tr}
	export WC=${WC:-\wc}
	export FOLD=${FOLD:-\fold}
	export WHICH="swarm.util.which"	# Defined in core.env
	export MKDIR="swarm.util.mkdir"	# Defined in core.env
	# These are required for internal functions to avoid security breaches
	# shellcheck disable=SC2155
	export -r PRINTABLE_PIPECHAR="$(${ECHO:-echo} -e \\u2502)" 2&>/dev/zero
	# shellcheck disable=SC2155
	export -r PRINTABLE_GREATER="$(${ECHO:-echo} -e \\u003e)" 2&>/dev/zero
	# shellcheck disable=SC2155
	export -r PRINTABLE_LESSER="$(${ECHO:-echo} -e \\u003c)" 2&>/dev/zero
#
# Date pre-formatting
#
	# Need to get these updating them self upon call, like: $($DATE_TIME_LOG)
	# Use these to set the date variable: `
	export DATE_TODAY="$DATE +%F"
	export DATE_TIME="$DATE +%T"
	export DATE_TIME_LOG="$DATE +%T.%N"
#
# Get proper SWARM root dir
#
	# If no SWARMDIR is provided, it is used in runtime as designed
	# However, 'SWARMDIR=$PWD/SWARM source SWARM/runtime' could be used as a speedbooster,
	# as it bypasses the multiple physical read attempts
	# SWARMDIR - MUST - be provided if you intend to store
	# the files in a dir not named SWARM
	if [[ "x" == "x$SWARMDIR" ]]
	then
		# Find the path that holds this script
		# Evaluate best chance for the dirs
		for tmp in "$0" "${PWD:-$($PWD_EXEC)}" ".." "${PWD:-$($PWD_EXEC)}/.."
		do
			if [[ "SWARM" == "${tmp##*/}" ]]
			then	# We're in it already
				# Usualy debug or tryout mode
				SWARM[ROOTDIR]="$tmp"
				unset tmp
				break
			fi

			if [[ -d "${tmp}/SWARM" ]]
			then	# It's a sub dir
				# As it should be called
				SWARM[ROOTDIR]="$tmp/SWARM"
				unset tmp
				break
			fi
		done
		# Should not reach this point
		# Other than while debug testing
		[[ -f ./runtime ]] && SWARM[ROOTDIR]="${PWD:-$(${PWD_EXEC})}"
		unset tmp
	else
		# Or optionaly, use the 'install' method
		# Verify the location
		if [[ -f "${SWARMDIR}/runtime" ]]
		then	# Assign the variable
			SWARM[ROOTDIR]="$SWARMDIR"
		else	# This is the last hardcoded 'english only' message
			$PRINTF '%s\n' "Fatal, provided SWARMDIR=$SWARMDIR dir not found - assumed: \"${SWARM[ROOTDIR]}\" and you are in ${PWD:-$(${PWD_EXEC})}."
			sleep 3
			return 1 || exit 1
		fi
	fi
#
# SWARM_DIR_* for proper re-use
# source this file and type: SWARM_DIR_<hit tabulator>
#
	# Some might wonder why I did not use BASH_SOURCE[0]
	# -> Because if it was sourced with a relative reference,
	# I would not get an abslute path
	SWARM_DIR_ROOT=${SWARM[ROOTDIR]}
	SWARM_DIR_DOCS="${SWARM_DIR_ROOT}/docs"
	SWARM_DIR_DATA="${SWARM_DIR_ROOT}/data"
	SWARM_DIR_CONF="${SWARM_DIR_DATA}/conf"
	SWARM_DIR_LIBS="${SWARM_DIR_DATA}/libs"
	SWARM_DIR_LANG="${SWARM_DIR_DATA}/lang"
	SWARM_DIR_LIST="${SWARM_DIR_DATA}/lists"
	SWARM_DIR_THEMES="${SWARM_DIR_DATA}/themes"
	SWARM_DIR_TEMPLATES="${SWARM_DIR_DATA}/templates"
#
# Load english strings for overall coverage of error messages.
# This is the default language, another one will only be attempted to load,
# if it is not starting with en_*  --> See line 260'ish
#
	for lang_file in "$SWARM_DIR_LANG/en_GB"/*.lang
	do
		# shellcheck disable=SC1090
		source "$lang_file" ## 2>/dev/zero	# Sadly, some strings cause issues as they rely on functions that are not yet loaded
		$PRINTF "."
	done
#
# Prepare File Descriptors (FD)
#
	# Prepare for SWARM interface descriptor:
	exec {FD_SWARM_UI}>/dev/tty
	# This is the backup swarm for stderr :: restore @ line 410'ish
	exec {FD_BASH_ERR_BKP}>&2
#
# Load SWARM settings, core and sanity functions
#
	# Start loading swarm
	declare tmp_swarm_loading="" 	tmp_len=0	tmp_empty=""
	for thisCFG in "${SWARM_DIR_CONF}"/* "${SWARM_DIR_LIBS}"/core.env
	do
		# shellcheck disable=SC1090
		source "$thisCFG"
		$PRINTF "."
	done
#
# SWARM Environment checks
#
	# Load functions
	for this in "${SWARM_DIR_LIBS}"/*
	do
		# Skip if core.env
		[[ "$this" == "$SWARM_DIR_LIBS/core.env" ]] && continue
		# Special handling for slow-mode
		if ${doSlowLoading:-false}
		then
			# This is off by default because nowadays it's too fast to see the regular way
			# Only recomended with numbers between 0.5 to 2 for application-like scripts
			# To have a 'cool intro'
			$PRINTF '\r%s' "$this"
			[[ $tmp_len -lt ${#this} ]] && \
					tmp_len=${#this} && \
					tmp_empty=$($PRINTF '%*s' $COLUMNS)
			sleep "${SWARM_INTERVALL_SLOW_LOADING:-0.3}"
			$PRINTF  "\r$tmp_empty" >&1
		fi
	# Minimalistic output
		tmp_swarm_loading="${tmp_swarm_loading}."
		if [[ ! "${this:0:2}" == "\.[\.]" ]]
		then	# shellcheck disable=SC1090
			if source "$this"
			then	# All good
				$PRINTF '\r%s' "${tmp_swarm_loading}" >&1
				${doLogExt:-false} && \
				 	init.msg "$SWARM_MSG_INIT_FILE_FOUND $this" >&2
			else	# Not good
				 ${doLogExt:-false} &&  \
					 init.msg "$SWARM_MSG_INIT_FILE_MISSING $this" >&1 >&2
			fi
		fi
	done
	unset tmp_swarm_loading \
			tmp_len \
			tmp_empty \
			this
#
# CORE is loaded, lets adapt the user settings
#
	# shellcheck disable=SC1090
	source "$SWARMRC"
#
# Load the users functions now
# if he has some that is
#
	# SWARM_USER_DIR_BASE was defined the the lib-functions
	# The following dirs should be kept to default, but can be overwritten
	# by the SWARMRC, also, SWARM_USER_DIR_BASE might have been customized
	SWARM_USER_DIR_CONF="${SWARM_USER_DIR_CONF:-${SWARM_USER_DIR_BASE}/conf}"
	SWARM_USER_DIR_LIBS="${SWARM_USER_DIR_LIBS:-${SWARM_USER_DIR_BASE}/libs}"

	if [[ -d "$SWARM_USER_DIR_BASE" ]]
	then
		# Create the dir if not existing yet (first time)
		for tDir in "$SWARM_USER_DIR_CONF" "$SWARM_USER_DIR_LIBS"
		do
			# shellcheck disable=SC2154
			$isDir "$tDir" >/dev/null || ${MKDIR:-swarm.util.mkdir} "$tDir"
		done
		# Parse and source User Files, if files exist
		# Read configuration files before functions
		for uf in "${SWARM_USER_DIR_CONF}/"* "${SWARM_USER_DIR_LIBS}/"*
		do
			# Dont work with an asterix
			[[ '*' == "${uf:-1}" ]] && continue
			# shellcheck disable=SC1090
			if [[ -f "$uf" ]]
			then
				# shellcheck disable=SC2015
				source "$uf" && \
					$PRINTF "." || \
					init.msg "$uf : $SWARM_MSG_INIT_FILE_MISSING" >&1 >&2
			fi
		done
	fi
#
# Prepare language for user caused errors
# As well as for all helpfiles and manpages
# that the user may call/ask by ./runtime help
#
	# Update language strings
	# to user language - if available
	swarm.update.lang
	swarm.update.lang.status
#
# Starting SWARM visuals now
#
	swarm.init.theme "$SWARM_THEME"
	swarm.update.geometry
#
# Reset the stderr filedescripter
# Only the startup sequence of SWARM should be loged (on errors)
#
	$CAT "${SWARM_LOG}.tmp" >> "${SWARM_LOG}"
	exec 2>&"${FD_BASH_ERR_BKP}"
#
# Initiate Interface : Runtime Executed
#
	# Check wether the runtime is executed or sourced
	# This is executed obviously:
	if [[ "runtime" = "${0##*/}" ]]
	then	# First time caller or missing arguments
		if [[ -z "$1" ]]
		then	# First Time // No arguments
			header "SWARM ${SWARM[VERSION]}-${SWARM[BUILD]} $SWARM_MSG_WORD_COPYRIGHT (C) 1995-2021 Simon Arjuna Erat (sea)" "$($DATE_TODAY) | $($DATE_TIME)"
			title "$SWARM_MSG_WORD_LICENSE"
			printe -n --center "$SWARM_MSG_PHRASE_WARRANTY1"
			printe -n --center "$SWARM_MSG_PHRASE_WARRANTY2"
			printe -n --center "$SWARM_MSG_PHRASE_WARRANTY3"
			title	"$SWARM_MSG_WELCOME_TITLE"
			status 1 "$SWARM_MSG_WELCOME_INFOLINE1"
			status 111 "$SWARM_MSG_WELCOME_INFOLINE2"
			printe "$SWARM_MSG_WELCOME_INFOLINE3" "${SWARM_USER_DIR_SCRIPTS}/SWARM"
			title	"$SWARM_MSG_WORD_ARGUMENTS"
			printe -2 -- <<< "$SWARM_MSG_WELCOME_CONTENT"
			exit 0
		else	# Has arguments, lets parse
			$PRINTF "$(swarm.print.goto 0)"
			case "${1,,}" in
			"config")
				shift
				swarm.eu.show.config "${@}"
				exit $?
				;;
			"demo")
				swarm.eu.demo
				exit $?
				;;
			"help" | "--help" | "-h")
				shift
				# Lets show a basic help menu
				swarm.eu.help.menu "${@}"
				exit $?
				;;
			"tarball")
				# shellcheck disable=SC2164
				cd "${SWARM_DIR_ROOT}/.."
				F="$HOME/swarm-${SWARM[BUILD]}-full.tar.gz"
				tar -acf "$F" "${SWARM_DIR_ROOT##*/}" 2&>/dev/null
				[[ -f "$F" ]]
				status $? "$F"
				cd "$OLDPWD"
				;;
			"tar")
				# shellcheck disable=SC2164
				cd "${SWARM_DIR_ROOT}/.."
				F="$HOME/swarm-${SWARM[BUILD]}.tar.gz"
				tar -acf "$F" --exclude ".git" "${SWARM_DIR_ROOT##*/}"  2&>/dev/null
				[[ -f "$F" ]]
				status $? "$F"
				cd "$OLDPWD"
				;;
			"new")
				case "$2" in
				"function")
					shift 2
					swarm.eu.new.function "${@}"
					;;
				"script"|"scripts")
					shift 2
					swarm.eu.new.scripts "${@}"
					;;
				*)
					swarm.eu.new.menu
					;;
				esac
				exit $?
				;;
			"words"|"word")
				title "$SWARM_MSG_WORD_WORDS"
				# shellcheck disable=SC2086
				swarm_wordlist="$($ECHO ${!SWARM_MSG_WORD_*})"
				declare C=0 T=0
				for this_word in $swarm_wordlist
				do
					((C++))
					((T++))
					if [[ $C -eq $(( ${LINES:-24} - 5 )) ]]
					then	C=0
						press #title
					fi
					printe "$T" "$this_word" "${!this_word}"
				done
				;;
			"phrase"|"phrases")
				title "$SWARM_MSG_WORD_PHRASES"
				# shellcheck disable=SC2086
				swarm_wordlist="$($ECHO ${!SWARM_MSG_PHRASE_*})"
				declare C=0 T=0
				for this_word in $swarm_wordlist
				do
					((C++))
					((T++))
					[[ $C -eq 10 ]] && \
						C=0 && \
						title
					printe "$T" "$this_word" "${!this_word}"

				done
				;;
			"log")
				if [[ "rm" == "$2" ]]
				then	$RM_EXEC "$SWARM_LOG"
					exit 0
				fi
				title "SWARM LOG"
				export COLUMNS=$COLUMNS LINES=$LINES TERM=$TERM
				# Sadly, this needs this workaround until i fixed FD2 usage for the log
				# My preference is more, wich fails the hardest in this situation :(
				${MORELESS} "$SWARM_LOG"
				exit $?
				swarm.util.which less >/dev/zero && \
					${MORELESS/more/less} "$SWARM_LOG" || \
					cat "$SWARM_LOG"
				exit $?
				;;
			"stats")
			#
			#	Vars
			#
				LINER="########################################"
				COMMENTS=0
				lines=0
				BLANKS=0
			#
			#	Action
			#
				# shellcheck disable=SC2164
				cd "$SWARM_DIR_ROOT"
				$ECHO "$LINER"
				$ECHO -e "\t$SWARM_MSG_STATS_TITLE \"${PWD##*/}\""
				# Get amount of functions
				count=0 ; num=0
				num=$(wc -l <<< $($GREP "[azAZ]()" ${SWARM[ROOTDIR]}/runtime $SWARM_DIR_LIBS/* ))
				#echo "num--$num"

			# Size
				$ECHO "$LINER"
				# shellcheck disable=SC2016
				swarm.list.dirtree . | swarm.str.dirsize -- | \
					${AWK:-awk} \
						-v FOLDER="$SWARM_MSG_STATS_FOLDERS" \
						-v KB="$SWARM_MSG_WORD_KB" \
						'{print $0;SUM=SUM+$1} END {print NR" "FOLDER" "SUM/1024" "KB}' | $SED s,"${SWARM_DIR_ROOT}\/",'',g
			# Files
				$ECHO "$LINER"
				FILES=$($FIND|$GREP -ve ".git" | $WC -l)
				eval "$ECHO" "$SWARM_MSG_STATS_FILES"
			# Lines
				for F in $($FIND|$GREP -ve ".git" -ve ".jpg" -ve ".png" -ve ".gif")
				do	if [[ -f "$F" ]]
					then
						# shellcheck disable=SC2016
						val_num=$($WC -l "$F" | $AWK '{print $1}')
						COMMENTS=$(( COMMENTS + $($GREP ^"#" "$F" | $WC -l) ))
						lines=$(( lines + val_num ))
						BLANKS=$(( BLANKS + $($GREP ^[[:space:]]$ "$F" | $WC -l) ))
					fi
				done
				$ECHO -e "$SWARM_MSG_STATS_LINES: \t\t $lines"
				$ECHO -e "$SWARM_MSG_STATS_COMMENTS: \t $COMMENTS"
				$ECHO -e "$SWARM_MSG_STATS_BLANK: \t\t $BLANKS"
				$ECHO -e "$SWARM_MSG_STATS_AVERAGE: \t $(( lines / FILES ))"

				# shellcheck disable=SC2164
				cd "$OLDPWD"
			;;
			remove)
				title "$SWARM_MSG_WORD_REMOVE: SWARM"
				printe "$SWARN_MSG_PHRASE_REMOVE_SWARM"
				yesno "$SWARM_MSG_WORD_REMOVE $SWARM_MSG_WORD_CONFIGURATION ($SWARMRC)?" || exit 1
				swarm.util.rm -v "$SWARMRC" "$SWARM_USER_DIR_BASE"
				swarm.cleanup remove
			;;
			theme)
				swarm.clear
				if [[ -n "$2" ]]
				then	swarm.update.theme "$2"
					cfg.set -v "$SWARMRC" "SWARM_THEME" "$2"
					exit 0
				else	newtheme=$(pick -m $(swarm.list.theme))
					if swarm.update.theme "$newtheme"
					then	cfg.set -v "$SWARMRC" "SWARM_THEME" "$newtheme"
					fi
					exit $?
				fi
				;;
			sysinfo)
				pre='swarm\.sysinfo\.'
				list=$(	declare | $GREP "$pre" | $AWK '/\(\)/ {print $1}' | $GREP -v ^"_" )
				toplevels=$($AWK -F. '{print $3}' <<< "$list"|uniq)
			# Output
				header --default "$SWARM_MSG_WORD_SYSTEM $SWARM_MSG_WORD_INFORMATION"
				for section in $toplevels
				do
					header "" "$section" ""
					#title "$($ECHO $(swarm.sysinfo.$section 2>/dev/zero || $ECHO $section))"
					subs=$($GREP "$section"  <<< "$list" | $AWK -F '.' '{print $4}'|uniq)
					tasks=""
					for s in $subs
					do
						if $GREP -q "${section}\.${s}\." <<< "$list"
						then	last+=" $s"
						else	first+=" $s"
						fi
					done
					tasks="$first $last"
					for sub in $tasks
					do
						if $GREP -q "${section}\.${sub}\." <<< "$list"
						then
							title "$sub"
						fi
						for l in $($GREP "\.${section}\." <<< "$list" | $GREP "$sub")
						do
							printe "$l" "$($ECHO $($l))"
						done
					done
				done

				exit

				for ls in $list
				do
					# Basics
					base="${ls/$pre/}"		# Remove the prefix: swarm.sysinfo.
					toplevel=${base/\.*}		# Remove everything after the first dot (.), should be: os, hw, net
					item="${base/*\.}"		# Remove everything before the last dot (.)
					# Now subsections, like: os.version, hw.audio or net.ssh
					checkval=${base/$toplevel}	# Remove the toplevel
					checkval=${checkval/$item}	# And the last item
					checkval=${checkval/\.}		# Any remaining dots


					echo "T$toplevel - i$item " # 		\t\t B$base - "
				#	if [[ ! "$item" == "$toplevel" ]]
				#	then	# item and toplevel are different,
						# so lets compare them

						# Lets handle toplevel sections: hw, os
						if [[ ! "$toplevel" == "$tlast" ]]
						then	header "" "$toplevel" ""
							title "$item"
							tlast="$toplevel"
						fi

						# Lets see if there is a subsection:
						if [[ -n "${checkval}" ]]  && [[ ! "$checkval" == "$ilast" ]]
						then	title "${checkval}"
							ilast="${checkval}"
						fi
				#	else	header "" "$toplevel" ""
				#		title "$item : $(swarm.sysinfo.$base)"
				#	fi
					printe "$ls:" "$($ECHO $($ls))"
				done
				;;
			esac
		fi
	fi
#
# Exit script or beginn user scripts
# If you want 'sucessfull' exit cone on sourceing this file,
# you got to have it this way.
#
! ${DEBUG:-false} || set +x
#
