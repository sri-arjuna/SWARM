#!/usr/bin/env bash
#
# Prepare LOG and TMP files
#
    if [[ 0 -eq ${UID:-${EUID:-0}} ]]
    then    # It's ROOT
            SWARM_LOG_DIR="/var/log"
            SWARM_TMP_DIR="/var/tmp"
    else    # It's a user, make sure we save to the right place
            declare tmp_worker
            tmp_worker="${XDG_CONFIG_DIR:-$HOME/.config}"
            SWARM_USER_CONFIG="$tmp_worker/swarm"
            # Not all mkdirs support creating subdirs...
            [[ -d "$tmp_worker" ]] || $MKDIR "$tmp_worker"
            [[ -d "$SWARM_USER_CONFIG" ]] || $MKDIR "$SWARM_USER_CONFIG"
            unset tmp_worker
            # Actualy set the required variables
            SWARM_LOG_DIR="${SWARM_USER_CONFIG}/logs"
            SWARM_TMP_DIR="${SWARM_USER_CONFIG}/tmp"
    fi
    for thisD in $SWARM_LOG_DIR $SWARM_TMP_DIR
    do
        [[ -d "$thisD" ]] || $MKDIR "$thisD"
    done
    SWARM_LOG="${SWARM_LOG_DIR}/all-swarm-internals.log"
    SWARM_TMP="${SWARM_TMP_DIR}/swarm-${SWARM_CODE}.tmp"
    # Finalize
    [[ ! -d "$SWARM_TMP_DIR" ]] && $MKDIR "$SWARM_TMP_DIR"
    #$TOUCH "$SWARM_TMP" ## No actual need to create an empty tempfile
#
# Prepare basic utility functions
#
    init.msg() { $PRINTF '%s\n' "$1" ;}
    init.log() { ${isRO:-false} && return ; [ -f "$SWARM_LOG" ] || ( $TOUCH "$SWARM_LOG" && >"$SWARM_LOG") ; init.msg "$DATE_TIME_LOG SWARM :: $1" >> "$SWARM_LOG";}
    init.log.msg() { init.msg "$1"; ! ${isRO:-false} || init.log "$1";}
    init.log.check() {
    # Checks for log path and logfile
    # Creates if required and prints date and or divider line
        local RET
        if [[ ! -f "$SWARM_LOG" ]]
        then
            # Make sure path exists
            $MKDIR "$SWARM_LOG_DIR"
            ! $TOUCH "$SWARM_LOG" && init.log.msg "${SWARM_MSG_INIT_LOG_FAIL} -> $SWARM_LOG @ uid:${UID:-$EUID}"
        fi
        # If todays date was not found, write it
        if $GREP "$DATE_CUR" "$SWARM_LOG" >/dev/null
        then    # Print a visual divider
                init.log " -------------------"  #>> "$SWARM_LOG"
                RET=$?
        else    # Date is missing, print that instead
                init.log "$DATE_CUR"
                RET=$?
        fi

        # Exit function
        return $RET
    }
#
# Make sure we can differ the date in the log,
# if this fails, no write access, RO?
#
    # Only check log if loging is enabled (default:true)
    ${doLog:-true} && init.log.check && isRO=false || isRO=true
#
# Sometimes all that is needed,
# is a propper Clean Up
#
swarm.cleanup() { #
# Clears all known variables and sub routines on terminal exit from memory
# This is for security and proper coding alike
    echo todo cleanup >&2
    unset ${!USER_*}

    for p in ${SWARM_PID_THEME}
    do
        kill -s SIGKILL $p
    done

    # Delete files
    [[ -f "$SWARM_TMP" ]] && $RM "$SWARM_TMP"

    # This as last for all the user display - and log - messages
    unset ${!SWARM_*}
    unset swarm.*
    }
#
#	Protection and Error handling
#
	break_on_injections() { # ARGS
	# Searches for injection subjects
	# Returns true if it finds some
		typeset arg ac=0
		for arg do
		ac="$((ac+=1))"
		case "$arg" in
		(*[';Â´|<&>']*|*':('*|*':-'*)
			printf "%s\n" "Aborting, injection detected! arg\${ac}='\$arg'"
			return 0
		;;
		esac
		done
		return 1
	}
    swarm.error() { # CALLER SCRIPT FUNCNAME LINENO [CONTENT]
        # Prints an error message and exits
        #
            caller="\$1" script="\$2" fname="\$3" lineno="\$4"
            shift 4 #2 #4

            content=($($ECHO "\${@}"))
            $PRINTF "\n"
            # The eval is required for the function to work after export
            eval $PRINTF '\t%s:\t%s\n' \\
                "Callerscript" "\$caller" \\
                "Scriptname" "\$script" \\
                "Functionname" "\$fname :: \$FUNCNAME" \\
                "Linenumber" "\$lineno :: \$LINENO"
            for cont in "\${content[@]}";do
                $PRINTF '\t* %s\n' "\$cont"
            done
            # Original
            #trap - HUP INT QUIT ABRT ALRM TERM EXIT
            # Neu
            swarm.cleanup
            traps_restore
            exit 1
        }
#
#	Traps & Error messages
#
    	traps_save() { saved_traps="$(trap)" ; export saved_traps;}
    	traps_restore() { eval \$saved_traps;}
    	export -f traps_save traps_restore
        export -f swarm.error swarm.cleanup
        traps_save
        # Start my own traps....
        trap "swarm.error \${CALLER:-\$0} \$0 '\$($ECHO -E \${@})'" ABRT ALRM HUP QUIT TERM
        trap "swarm.cleanup" ABRT QUIT TERM KILL HUP ALRM
