#!/usr/bin/env bash
cfg.edit() { #
#
#
	script_version=0.9.2
	script_created="2014.11.03"
	script_changed="2016.01.24"

	script_name="$FUNCNAME"
	script_title="$SWARM_MSG_CFG_EDIT_TITLE"
	script_header="$script_name ($script_version)"
#
#	Shared variables & Language
#
	swarm.protect "${@}" && exit 1
#
#	Variables
#
	if [[ -z "$1" ]]
	then	# Its empty...
		swarm.help.usage cfg.edit
		return 1
	else	# We got a valid argument:
		typeset -r CFG="$1"
	fi
	typeset -r LOG="$TUI_DIR_LOGS/${script_name}.log"
	declare TMP="${TUI_DIR_TEMP:-TMPDIR}/${script_name}-$$.tmp~"
	declare -A OPTIONS DEFAULTS INDEX TYPE LABELS
	declare -a FILES
	FILE_LABEL=""
	WAIT_SECONDS=1
	do_write_file=false
	do_hide_edit=false
	be_quiet=false
	be_clear=false
	>"$TMP"	# Clear content
#
#	Traps
#
	trap "exit 130" INT ABRT KILL
	trap "exit $?" QUIT
#
#	Messages to translate:
#
	MSG_TR_WORD_BACK="$SWARM_MSG_WORD_BACK"
	MSG_TR_WORD_EDIT="$SWARM_MSG_WORD_EDIT"
	MSG_TR_SELECT_FILE="$SWARM_MSG_PHRASE_SELECT_FILE"
	MSG_TR_CHANGE_VALUE="$SWARM_MSG_CFG_EDIT_SELECT_VAR"
	#MSG_TR_YY="$(eval_gettext '')"
#
#	Functions
#
	cleanup() {
	# Removes all known tempfiles and exits
	# Is called at the end of the script and by the trap
		declare -a arr_CLEANUP=(
			"$TMP"
			# Add your tempfiles
			# here
			)
		for remove in "${arr_CLEANUP[@]}"
		do 	( [ -f "$remove" ] || [ -p "$remove" ] ) && rm -f "$remove"
		done
	}
	edit_file() { # /path/to/FILE
	#
	#
		#set -x
		CONF="$1"
		MODE=input
		[ -n "$(echo ${INDEX[@]})" ] && \
			OPTS_FOUND=(${INDEX[@]}) || \
			OPTS_FOUND=($(cfg.get -l "$CONF"))
		while 	# Preview
			#clear
			title "${FILE_LABEL:-$CONF}"
			for item in "${OPTS_FOUND[@]}"
			do 	printe  "$item" "$(cfg.get $CONF $item)"
			done
			tui-print

			# Select value or back
			printe  "$MSG_TR_CHANGE_VALUE"
			[ "true" = "$do_hide_edit" ] && this_edit="" || this_edit="$MSG_TR_WORD_EDIT"
			action=$(pick "$MSG_TR_WORD_BACK" $this_edit "${OPTS_FOUND[@]}" || exit 1)
			# Back or prepare variables
			[ ! "$MSG_TR_WORD_BACK" = "$action" ] || break
		do
			# Edit
			if [ "$action" = "$this_edit" ]
			then	edit "$CONF"
				continue
			fi
		# Exit on cancel
			[ -z "${action/^[*}" ] && break
		# Print label
			printe
			LBL="${LABELS[$action]}"
			[ -n "$LBL" ] && status 111 "$LBL"
		# Get current values
			curval=$(cfg.get "$CONF" "$action")
			vTYP="${TYPE[$action]}"
		# Prepare the question
			QUESTION="$(eval $ECHO $SWARM_MSG_CFG_EDIT_VALUE_NEW)"
		# Prepare and execute according action
			[ -z "$vTYP" ] && vTYP=input
			case "$vTYP" in
			input)
				if ! newval=$(ask"$QUESTION")
				then	return 1
				fi
				;;
			select)
				printe  "$QUESTION"
				newval=$(pick ${OPTIONS[$action]}) || exit 1
				;;
			esac

			if [ -z "$newval" ]
			then 	printf "\n"
				exit 1
			#	tui-yesno "$(eval_gettext 'Set $action to "$newval"?')" && \
			#		cfg.set -v "$CONF" "$action" "$newval"
			else 	cfg.set -v "$CONF" "$action" "$newval"
			fi
			$be_clear && wait "$WAIT_SECONDS" && clear && header "$script_header"
		done
	}
	cfg.edit.write_default() { # FILE
	# Writes the file if missing
	# and fills in all default values if missing
		[ -z "$(echo ${INDEX[@]})" ] && status 1 "$(gettext 'No --options OPTNAME passed to write!')" && exit 1
		thisConf="$1" ; [ -z "$thisConf" ] && echo "$(gettext 'Must provide a FILE to $FUNCNAME')" && return 1
		doOverwrite=false;if [ ! -f "$thisConf" ]; then touch "$thisConf" && doOverwrite=true|| return 1 ;fi
		$doOverwrite && cat "$TMP" > "$thisConf"
		for thisOpt in "${INDEX[@]}";do
			$GREP -q "$thisOpt" "$thisConf" || printf '%s\n' "${thisOpt}=${DEFAULTS[$thisOpt]}" >> "$thisConf"
		done
		$be_quiet && exit
	}
#
#	Traps are cool!
#
	# TRAP FUNCTION/"COMMAND" MODE's ...
	trap cleanup INT QUIT KILL ABRT
#
#	Get options
#
	# -a|--alternative ; to allow longoptions with a single leading '-'
	GETOPT=$(getopt \
		--options	"hT:H:qF:cw:" \
		--longoptions	"help,version,wait:,kiosk,file:,title:,header:,conf-header:,option:,default:,values:,label:,write-no-exist" \
		--name 		"${0##*/}" -- "${@}" \
	)
	eval set -- "${GETOPT}";C=0
	while true
	do 	#unset OPTS[@]
		case "$1" in
		-h|--help)	show_help	;;
		--version)	show_version	;;
		--)		shift ; break	;;
		# --------------------------------
		-H|--header)	script_header="$2"
				shift 2		;;
		-T|--title)	script_title="$2"
				shift 2		;;
		-F|--file)	FILE_LABEL="$2"
				shift 2		;;
		--conf-header)	cat >> "$TMP" <<-EOF
				# $2
				EOF
				shift 2 	;;
		--option)	INDEX["$2"]="$2"
				LASTOPT="$2"
				shift 2 	;;
		--default)	DEFAULTS[$LASTOPT]="$2"
				shift 2 	;;
		--values)	OPTIONS[$LASTOPT]="$2"
				TYPE[$LASTOPT]="select"
				shift 2 	;;
		--label)	LABELS[$LASTOPT]="$2"
				shift 2 	;;
		--write-no-exist)
				do_write_file=true
				shift		;;
		-q)		be_quiet=true
				shift 		;;
		-c)		be_clear=true
				shift 		;;
		--kiosk)	do_hide_edit=true
				shift		;;
		--wait|-w)	WAIT_SECONDS="$2"
				shift 2 	;;
		esac
		[ -z "$1" ] && LASTOPT=""
		((C++));[ $C -gt 100 ] && break
	done
	FILES=("${@}")
	[ ${#FILES[@]} -lt 1 ] && show_help
#
#	Action & Display
#
	$do_write_file && cfg.edit.write_default "$1"
	while 	header "$script_header" "$(date +'%F %T')"
		title "$script_title"
	do 	if [ ${#FILES[@]} -ne 1 ]
		then 	printe  "$MSG_TR_SELECT_FILE"
			thisFile=$(pick  "$MSG_TR_WORD_BACK" "${FILES[@]}")
			[ -f "$thisFile" ] || break
		else	edit_file "$FILES"
			RET=$?
			break
		fi
		edit_file "$FILES"
		RET=$?
		$be_clear && wait $WAIT_SECONDS && clear && header "$script_header"
	done
#
# 	Clean up & exit
#
	cleanup
	return $RET
}
