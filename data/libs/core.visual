#!/usr/bin/env bash
#
# Prepare 'constant' variables
#
	export -r clrCL="\e[2K" 2&>/dev/zero
	# shellcheck disable=SC2154
	export -r PRINT_RIGHT_OUT="$c_reset" 2&>/dev/zero
#
# For easier code reusage, lets combine all math into a sub process
# This also makes sure COLUMNS and LINES are set and accurate
#
	# shellcheck disable=SC2086
	unset ${!len*}
	#shellcheck disable=SC2120
	swarm.update.geometry() { #
		# No can do, Only assign & export var if it does not exist
		# shellcheck disable=SC2155
		[[ -z "$COLUMNS" ]] && export COLUMNS="$(${TPUT:-\tput} cols)"
		# shellcheck disable=SC2155
		[[ -z "$LINES" ]] && export LINES="$(${TPUT:-\tput} lines)"

		# Set basic values
		export BORDER_LEFT="${SWARM_THEME_DATA[border-left]}"
		BORDER_RIGHT="${SWARM_THEME_DATA[border-right]}"	# Do not export just yet
		export clrFRONT="${SWARM_THEME_DATA[color-front]}"
		export clrBACK="${SWARM_THEME_DATA[color-back]}"
		export BAR="${SWARM_THEME_DATA[bar]}"
		export BAR_EMPTY="${SWARM_THEME_DATA[bar-empty]}"
		# Check if border-right was set:
		[ -z "$BORDER_RIGHT" ] && \
				for((i=${#BORDER_LEFT}-1;i>=0;i--)); do BORDER_RIGHT="$BORDER_RIGHT${BORDER_LEFT:$i:1}"; done
		# Now we can export it for sure
		export BORDER_RIGHT
		# Get some numbers
		export lenLeft="${#BORDER_LEFT}"
		export lenRight="${#BORDER_RIGHT}"
		export lenClrFont=${#clrFRONT}
		export lenClrBack=${#clrBACK}
		export identRight=$(( lenRight - 1 ))
		#export identRight=$(( lenRight + 4 ))

		# Pre-Calculate positions
		export numHALF=$(( COLUMNS / 2 ))
		export numEND=$COLUMNS ##$(( numHALF * 2 ))
		export posEND="\33[${numEND}G"
		# swarm.print.border still needs extra handling for posLEFT
		export posLEFT="\33[$(( lenLeft + 2 ))G"

		# Set colors
		c_front=$(swarm.color.fg "${SWARM_THEME_DATA[color-front]}")
		c_back=$(swarm.color.bg "${SWARM_THEME_DATA[color-back]}")
		export c_front c_back

		# If user wants extended logs, he shall have it
		! ${isRO:-false} && ${doLogExt:-false} && init.log "$SWARM_MSG_INIT_PID_GEOMETRY: ${PPID:-$PID}"
	}
	#export -f swarm.update.geometry
#
# Theme's
#
	swarm.update.theme() { # THEME_NAME
	# This loads the provided THEME_NAME
	#
		# This an assigned array containg the theme related data
		# Lets make sure each theme gets loaded into clear memory
		unset SWARM_THEME_DATA[@]	# Use terminal / console / vtr default settings as base
		# These are it's assingments
		#swarm_list_theme_options="border-left border-right color-font color-back read select"
		# Lets start fresh
		declare -Ag SWARM_THEME_DATA
		local ret=false
		# shellcheck disable=SC2015
		${isRoot:-false} && \
			local this_theme="${1:-default-red}" || \
			local this_theme="${1:-default-blue}"
		# Always use the user themes first
		# in case someone wants to pseudo-overwrite the default themes
		for there in "$SWARM_USER_DIR_BASE/themes" "$SWARM_DIR_THEMES"
		do
			# check in each dir
			if [[ -d "$there" ]]
			then	if [[ -f "$there/$this_theme" ]]
				then	# shellcheck disable=SC1090
					source "$there/$this_theme" || init.log "$there/$this_theme : $SWARM_MSG_PHRASE_FILENOTFOUND"
					ret=$?
				fi
			fi
		done

		# Check if something went wrong
		if [[ $ret != 0 ]]
		then	# The theme could not be Found
			# Lets fallback to default
			# shellcheck disable=SC1090
			${isRoot:-false} && \
				local this_theme="default-red" || \
				local this_theme="default-blue"
			source "$SWARM_DIR_THEMES/$this_theme"
			status $? "$SWARM_MSG_INIT_THEME"
			init.log.msg "$SWARM_MSG_INIT_THEME : $1 / $this_theme"
		fi
		# Export the values now
		export SWARM_THEME_DATA
		# Now, return
		return $ret
	}
	#shellcheck disable=SC2120
	swarm.list.theme() {
	# Lists all themes available
	# Includes SWARM_USER_DIR_BASE/themes and SWARM_DIR_THEMES alike
		local d f
		for d in "$SWARM_USER_DIR_BASE/themes/" "$SWARM_DIR_THEMES/"
		do
			# Check if path exists and handle each file for its own
			if [[ -d "$d" ]]
			then	# It exists, lets parse it
				for f in "$d"/* #$($LS "$d")
				do
					# Output only if it really is a file
					[[ -f "$f" ]] && $PRINTF '%s\n' "${f##*/}"
				done
			else	# It does not exist yet
				# Lets prepare for custom themes
				$MKDIR "$d"
			fi
		done
	}
	#shellcheck disable=SC2120
	swarm.init.theme () { #
	# Initiate the theme for the first time
	# This is only a wrapper for the initial loading.
		swarm.update.theme "${SWARM_THEME:-default-red}"
	}
#
# Visual outputs - core essentials
#
	swarm.clear() { #
	# Clears the printed line from all previous output
	#
		$PRINTF "\e[2K"
	}
	#shellcheck disable=SC2120
	swarm.list.color() { #
	# Simply lists the color names that can be used in SWARM
	# Reads from the colors.conf file of SWARM if the variables are not found in memory.
		# shellcheck disable=SC2154
		if [[ -z "$cb_black" ]]
		then	# The variables are empty
			# need to read from file
			local raw=""
			# shellcheck disable=SC2140
			raw=$($GREP "cb_" "${SWARM_DIR_DATA}/conf/colors.conf" | $SED s,"cb_","",g ) #| $SED s,"="," ",g | $AWK ' $1'
			for r in $raw
			do
				$PRINTF '%s\n' "${r/=*}"
			done
		else	# Variables are available
			local tmp_str=""
			# Generate an end user optimized list
			for t in ${!cb_*}
			do	tmp_str="$tmp_str ${t/cb_}"
			done
			# Output
			# shellcheck disable=SC2086
			$PRINTF '%s\n' $tmp_str
		fi
	}
	swarm.color.bg() {  # COLORNAME
	# Returns the color code of provided COLORNAME
	#
		local str=cb_${1:-blue}
		eval "$PRINTF" \$"${str}"
	}
	swarm.color.fg() {  # COLORNAME
	# Returns the color code of provided COLORNAME
	#
		local str=cf_${1:-white}
		eval "$PRINTF" \$"${str}"
	}
	swarm.print.goto() { # NUM
	# Returns the positioncode for passed NUM location
	# Returns number 0 if no argument is passed
		# shellcheck disable=SC2128
		$PRINTF "\33[${1:-0}G"
	}
	swarm.print.bold() { # "STR"
	# Returns STR with wrapped code for BOLD
	#
		# shellcheck disable=SC2145
		$PRINTF "\033[1m${@}\033[0m"
	}
	swarm.print.blink() { # "STR"
	# Returns STR with wrapped code to blink
	#
		# shellcheck disable=SC2145
		$PRINTF "\033[5m${@}\033[0m"
	}
	swarm.print.stroke() { # "STR"
	# Returns STR with wrapped code for STROKE
	#
		# shellcheck disable=SC2145
		$PRINTF "\033[9m${@}\033[0m"
	}
	swarm.print.underline() { # "STR"
	# Returns STR with wrapped code for UNDERLINE
	#
		# shellcheck disable=SC2145
		$PRINTF "\033[4m${@}\033[0m"
	}
	# shellcheck disable=SC2120
	swarm.print.border() { # [-h -t -c]
	# Prints basic border for all lines, this should only be executed if COLUMNS > 25
	# The calling function has to handle the NEWLINE required by 'printe' (-E)
		# Makes no sense to print visuals on such short lines
		[[ ${COLUMNS} -lt $SWARM_SKIP_THEME_WIDTH ]] && return 1
	# Get args
		local MODE="" #name=""
		case "${1/-}" in
		h)	MODE="header"	;;
		t)	MODE="title"	;;
		c)	$PRINTF "\e[2K" >&"${FD_SWARM_UI}"	;;
		*)	MODE="basic"	;;
		esac
	# Make sure values are udpated
		swarm.update.geometry
	# Now prepare the seperate handling
		case "$MODE" in
		"basic")
			PRINT_LEFT_IN="$c_reset"
			PRINT_LEFT_OUT="${clrCL}${c_front}${c_back}"
			PRINT_RIGHT_IN="${c_front}${c_back}"
			pos_cor_num=0
			;;
		"header")
			local filler_num="" filler_str=""
			filler_num=$(( numEND - $(( lenRight + lenLeft ))  ))
			filler_str=$($PRINTF "%*s" ${filler_num})
			PRINT_LEFT_IN="$filler_str" #$c_reset"
			PRINT_LEFT_OUT="${clrCL}${c_front}${c_back}"
			PRINT_RIGHT_IN="" #${c_front}${c_back}"
			pos_cor_num=0
			;;
		"title")
			local filler_num=""
			filler_num=$(( COLUMNS - $(( lenRIGHT + lenLeft )) - 2  ))
			local filler_str=""
			filler_str=$($PRINTF "%*s" ${filler_num})
			# shellcheck disable=SC2154
			PRINT_LEFT_IN="${c_invert}$filler_str" #$c_reset"
			PRINT_LEFT_OUT="${clrCL}${c_front}${c_back}"
			PRINT_RIGHT_IN="${c_reset}${c_front}${c_back}"
			pos_cor_num=0
			;;
		*)	pos_cor_num=0 ;;
		esac
	# Get some numbers
#		local identRight=$(( lenRight + ${#clrCL}  ))
		local posLEFT="\33[$(( lenRight - 2 ))G"
		local posRIGHT="\33[$(( numEND - lenRight - pos_cor_num +1 ))G"
	# Well, left aligned it works. isnt too hard
		$PRINTF "\r${PRINT_LEFT_OUT}${posLEFT}${BORDER_LEFT}${PRINT_LEFT_IN}${posRIGHT}${PRINT_RIGHT_IN}${BORDER_RIGHT}${PRINT_RIGHT_OUT}${c_reset}\r" >&"${FD_SWARM_UI}"
	}
	swarm.print.text() { # [-h -t] [ LEFT ] [ CENTER ] [ RIGHT]
	# This simply puts the text
	# according to MODE
		# Had to disable because I sent bold text through this for title... hmm.. disable?
		local fix_header_r=0
		local MODE=basic ORIENTATION=default
		local doNewline=false doReturn=false
		while :;
		do
			case "${1}" in
			"-t")	MODE=title
				doNewline=true
				split_opt="$1"
				;;
			"-h")	MODE=header
				fix_header_r=0
				doNewline=true
				split_opt="$1"
				;;
			"-n") 	doNewline=true
				;;
			"-r") 	doReturn=true
				;;
			"--center")
				ORIENTATION=center
				doReturn=true
				doCenter=true
				;;
			"--left")
				ORIENTATION=left
				doReturn=true
				;;
			"--right")
				ORIENTATION=right
				doReturn=true
				;;
			*)	break
				#swarm.help.usage "${FUNCNAME}"
				#return 1
					;;
			esac
			shift
		done

		# Check if it is too short, if so, print fallback mode and return
		[[ ${COLUMNS} -lt 25 ]] && \
			$PRINTF "%s\n" "${@}" >&1 && \
			return 1

		# Make sure values are udpated
		swarm.update.geometry

	# Get the actual string
		local ARGS=("${@}")
		local L="${ARGS[0]}"
		local M="${ARGS[1]}"
		local R="${ARGS[2]}"
	# Retrieve their length
		local lenEvalLeft=${#L}
		local lenEvalMiddle=${#M}
		local lenEvalRight=${#R}
	# Before we attempt to print anything, lets check about the length
		local lenBorder=$(( lenRight + lenLeft + 2 ))
		local len_strings_total=$(( lenEvalLeft + lenEvalMiddle + lenEvalRight ))
		local len_max_length=$(( COLUMNS - lenBorder ))
	# Now check wether we need to split or not
	# Output
		case ${#@} in
		0)	# Nothing to print
			$PRINTF "${posLEFT}"
			;;
		1)	# Just left oriented
			case "$MODE" in
			"basic")
				if $doCenter
				then
					echo heer
					local posMIDDLE="\33[$(( numHALF - $(( ${#L} / 2 ))   ))G"
					$PRINTF "${posMIDDLE}$L${c_reset}" >&"${FD_SWARM_UI}"
				else
					$PRINTF "${posLEFT}$L" >&"${FD_SWARM_UI}"
				fi
				;;
			"title")
				local posMIDDLE="\33[$(( numHALF - $(( ${#L} / 2 ))   ))G"
				$PRINTF "${posMIDDLE}${c_front}${c_back}${c_invert}$L${c_reset}" >&"${FD_SWARM_UI}"
				;;
			esac
			;;
		3)
			# Default handling
			local posMIDDLE="\33[$(( numHALF - $(( ${#M} / 2 ))  ))G"
			local split_opt=""
			local header_start="" header_end=""
			local posRIGHT="\33[$(( numEND - identRight - lenEvalRight - 1  ))G"
		# Prepare variables
			case "$MODE" in
			"header")
				split_opt+="-h -n"
				header_start="${c_front}${c_back}"
				header_end="${c_reset}"
				local posRIGHT="\33[$(( numEND - identRight - ${#R} - 1 - fix_header_r ))G"
				;;
			esac
		# Actualy print
			if [[ ${#L} -gt $(( COLUMNS - lenRight - lenLeft - 2 )) ]]
			then	# L Needs splitting
				swarm.str.split "$L" >/dev/zero
				swarm.print.text $split_opt "$SPLIT1"
				swarm.print.border $split_opt
				swarm.print.text $split_opt "$SPLIT2" "$M" "$R"
			elif [[ ${#M} -gt $(( COLUMNS - lenRight - lenLeft - 2 )) ]]
			then	# R Needs splitting
				swarm.str.split "$M" >/dev/zero
				swarm.print.text $split_opt "$L" "$SPLIT1" ""
				swarm.print.border $split_opt
				swarm.print.text $split_opt "" "$SPLIT2" "$R"
			elif [[ ${#R} -gt $(( COLUMNS - lenRight - lenLeft - 2 )) ]]
			then	# R Needs splitting
				swarm.str.split "$R" >/dev/zero
				swarm.print.text $split_opt "$L" "$M" "$SPLIT1"
				swarm.print.border $split_opt
				swarm.print.text $split_opt "" "" "$SPLIT2"
			elif [[ $(( ${#L} + ${#M} + ${#R} )) -gt $(( COLUMNS - lenRight - lenLeft - 2 )) ]]
			then	# 1 and 2 need be seperated
				swarm.print.text $split_opt "$L"
				swarm.print.border $split_opt
				swarm.print.text $split_opt "" "$M" ""
				swarm.print.border $split_opt
				swarm.print.text $split_opt "" "" "$R"
			else	# Normal output
				swarm.print.border $split_opt
				$PRINTF "${posLEFT}${header_start}$L${posMIDDLE}$M${posRIGHT}$R${header_end}"
			fi
			;;
		esac
		$doReturn && $PRINTF "$(swarm.print.goto 0)"
		$doNewline && $PRINTF "$(swarm.print.goto $COLUMNS)\n"
	}
	swarm.str.split() { # "STRING"
	# Splittes passed string in half at the nearest word
	# and prints each part as a new line
		local beQuiet=false
		case "$1" in
		"-"|"--")
			shift
			while $READ -r line;do
				$FUNCNAME "$line"
			done
			return 0
			;;
		""|-h|--help|-\?)
			swarm.help.usage "$FUNCNAME"
			return 1
			;;
		"-q")	beQuiet=true
			;;
		esac
	# Vars
		local str="" ; str="${*}"
		local tmp_count ; tmp_count=$(( ${#str} / 3 * 2 ))
		local two_liner=""
		SPLIT1=""
		SPLIT2=""
	# Action
		tmp=$(( COLUMNS / 2 ))
		[[ 0 -eq $tmp_count ]] && tmp_count=$tmp
		two_liner=$($FOLD -sw "$tmp_count" -- <<< "$1")
		$beQuiet || $ECHO "$two_liner" >&1
	# Env
		SPLIT1=$( head -n1 -- <<< "$two_liner")
		SPLIT2=$( tail -n1 -- <<< "$two_liner")
	}
	swarm.str.status() { # ERRNUM
	# Returns the string to be printed according to ERRNUM
	# This already takes care of terminal only or GUI visuals
		#
		# Colors
		#
			local R="${SWARM_COLOR_RESET}"
			local r="${SWARM_COLOR_FG_RED}"
			local y="${SWARM_COLOR_FG_YELLOW}"
			local p="${SWARM_COLOR_FG_PURPLE}"
			local g="${SWARM_COLOR_FG_GREEN}"
			local b="${SWARM_FONT_BOLD}"
			#local S="${SWARM_FONT_STROKE}"
			local c_clr=""
		#
		# Check wether it is an X session
		#
		if ${isGUI:-false}
		then 	# Yes it is
			case "$1" in
			"0")	value=" ${g}${b}✓${R}  "
				;;
			"1")	value=" ${r}${b}✗${R}  "
				;;
			"2")	value=" ${y}${b}∞${R}  "
				;;
			"3")	value=" ${p}${b}≣${R}  "
				;;
			"4")	value=" »  "
				;;
			"5")	value=" >  "
				;;
			"6")	value=" <  "
				;;
			"7")	value=" ${r}${b}✗${R}  "
				;;
			"10")	value=" ${g}${b}◆${R}  "
				;;
			"11")	value=" ${r}${b}◇${R}  "
				;;
			"99")	value=" ⅈⅈ "
				;;
			"111")	value="${STATUS_TEXT[111]}"
				;;
			"127")	value=" ${r}${b}✗${R}  "
				;;
			"130")	value=" ${r}${b}✗${R}  "
				;;
			esac
		else	# It's TTY / plain console
			value="${STATUS_TEXT[$1]}"
			case ${#value} in
			1)	value="  ${value^^} "	;;
			2)	value=" ${value^^} "	;;
			3)	value=" ${value^^}"	;;
			4)	value="${value^^}"	;;
			esac

			case "$1" in
			"0"|"10")		c_clr="${g}"	;;
			"1"|"7"|"11")		c_clr="${r}"	;;
			"2"|"99"|"111") 	c_clr="${y}"	;;
			"3"|"127"|"130")	c_clr="${p}"	;;
			esac
		fi
		$PRINTF "[ ${c_clr}${value}${R} ]"
	}
