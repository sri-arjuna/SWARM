#!/usr/bin/env bash
#
# Prepare functions
# that are supposed to be used by 'enduser' script authors
# Stuff like: yeno, pick, printe, header, title and 'all the rest'
#
#
# Visual outputs - 'End user' stuff
#
	header() { # LEFT CENTER RIGHT
	# This prints a full line in blue (default-back), with white (default-front) text
	# TODO long string adjustments TODO, uses script_{name,version} before it uses its SWARM counterparts
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		swarm.print.border -h
		case "$1" in
		"--")
			shift
			while read line;do
				header "" "$line" ""
			done
			return 0
			;;
		"--default")
			shift
			swarm.print.text -h \
				"${script_name:-SWARM} ${script_version:-${SWARM[VERSION]}-${SWARM[BUILD]}} ($(swarm.os.distro|$SED s,'"','',g))" \
				" " \
				"$($PRINTF '%s ' ${@}) | $($DATE_TODAY) / $($DATE_TIME)"
			;;
		*)
			swarm.print.text -h "$1" "$2" "$3"
			;;
		esac
		$PRINTF "$posEND\n"
	}
	title() { # Text
	# This prints a single centered string on a line
	# It has blue borders and fills the inner line with white (Default-{front,back})
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		if [[ "--" == "$1" ]]
		then
			while read line;do
				title "$line"
			done
			return 0
		else
			swarm.print.border -t
			swarm.print.text -t "${1}"
			$PRINTF "$posEND\n"
		fi
	}
	printe() { # [-|--] STR1 STR2 STR3
	# Simply prints the strings as passed, it requires 3 strings to use the center
	# For piping, it expects 3 lines, each representing 1 variable
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#set -x
		local MODE="none"
		# Get args
		case "$1" in
		"-1"|"-2")	MODE="${1/-}"
				shift
				;;
		*)		MODE="normal"
				;;
		esac
		# Get arg number if not forced yet
		[[ "normal" == "$MODE" ]] && [[ "-" != "$1" ]] && [[ "--" != "$1" ]] && MODE=${#@}
		# Get pipe?
		case "$1" in
		"--"|"-")
			shift
			case "$MODE" in
			"2")
				# Read pipe, expect 2 lines
				while read LEFT
				do
					read RIGHT
					printe "$LEFT" "" "$RIGHT"
				done
				return 0
				;;
			"1")
				# Read pipe, expect 1 lines
				while read LEFT
				do
					printe "$LEFT"
				done
				return 0
				;;
			*)
				# Read pipe, expect 3 lines (default)
				while read LEFT
				do
					read CENTER; read RIGHT
					printe "$LEFT" "$CENTER" "$RIGHT"
				done
				return 0
				;;
			esac
			;;
		esac
		#set +x
		case "$MODE" in
			"0")
				swarm.print.border -e
				swarm.print.text -e "" "" ""
				;;
			"1")
				swarm.print.border -e
				swarm.print.text -e "$1" "" ""
				;;
			"2")
				swarm.print.border -e
				swarm.print.text -e "$1" "" "$2"
				;;
			"3")
				swarm.print.border -e
				swarm.print.text -e "$1" "$2" "$3"
				;;
		esac
		$PRINTF "$posEND\n"
	}
	printl() { # [-|--] STR1 STR2 STR3
	# Simply prints the strings as passed, stays on the same line
	# It requires 3 strings to use the center
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#set -x
		local MODE="none"
		# Get args
		case "$1" in
		"-1"|"-2")	MODE="${1/-}"
				shift
				;;
		*)		MODE="normal"
				;;
		esac
		# Get arg number if not forced yet
		[[ "normal" == "$MODE" ]] && [[ "-" != "$1" ]] && [[ "--" != "$1" ]] && MODE=${#@}
		# Get pipe?
		case "$1" in
		"--"|"-")
			case "$MODE" in
			"2")
				# Read pipe, expect 2 lines
				while read LEFT
				do
					read RIGHT
					printe "$LEFT" "" "$RIGHT"
				done
				return 0
				;;
			"1")
				# Read pipe, expect 1 lines
				while read LEFT
				do
					printe "$LEFT"
				done
				return 0
				;;
			*)
				# Read pipe, expect 3 lines (default)
				while read LEFT
				do
					read CENTER; read RIGHT
					printe "$LEFT" "$CENTER" "$RIGHT"
				done
				return 0
				;;
			esac
			;;
		esac
		#set +x
		case "$MODE" in
			"0")
				swarm.print.border -e
				swarm.print.text -e "" "" ""
				;;
			"1")
				swarm.print.border -e
				swarm.print.text -e "$1" "" ""
				;;
			"2")
				swarm.print.border -e
				swarm.print.text -e "$1" "" "$2"
				;;
			"3")
				swarm.print.border -e
				swarm.print.text -e "$1" "$2" "$3"
				;;
		esac
	}
#
# Visual outputs - 'End user' stuff - Core Convenience
#
	yesno() { # "What question?"
	# Ask a yes/no question, returns 0/true for yes and 1/false for no
	# y/n are taken from language file and are used in code
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		local Y="${SWARM_MSG_WORD_YES:0:1}"
		local N="${SWARM_MSG_WORD_NO:0:1}"
		# Check if 'yesno' is empty, if so, fill with fallback values
		case "$1" in
		"--help"|"-h")
			swarm.help.screen "${SWARM_MSG_HELP_YESNO}"
			return 99
			;;
		esac
		[[ -z "${SWARM_MSG_WORD_YES}${SWARM_MSG_WORD_NO}" ]] && \
			SWARM_MSG_WORD_YES="+" && \
			SWARM_MSG_WORD_NO="-"

		swarm.print.border -e
		# Print the text
		local yn="${SWARM_MSG_WORD_YES:0:1}${SWARM_MSG_WORD_NO:0:1}"
		local str1="$(swarm.print.goto $(( ${#SWARM_THEME_DATA[border-left]} + 2  )))$1 (${yn,,})"
		# Move the cursor
		local str2="$(swarm.print.goto $(( $COLUMNS / 2 * 2 - ${#SWARM_THEME_DATA[border-left]} - 2  )))"
		local RET=""
		while [[ -z "$RET" ]]
		do
			$PRINTF "$str1"
			$PRINTF "$str2"
			builtin read -n 1 answer

			case "$answer" in
			"+"|"${Y,,}")
				RET=0
				;;
			"-"|"${N,,}")
				RET=1
				;;
			esac
		done
		# Leave line
		$PRINTF "$posEND\n"
		return $RET
	}
	status() { # [ -r -c] $? ["Text Left"] ["Text Center"]
	# Prints text and exit with passed return code
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		unset RET TXT1 TXT2
		local doReturn=false
	# Check for options
		for opt in "${@}"
		do
			case "${opt}" in
			"-r")
				doReturn=true
				shift
				;;
			"-c")
				$PRINTF "$(swarm.print.goto 0)\e[2K"
				shift
				;;
			esac
		done
	# Check for minimal arguments
		[[ -z "$1" ]] && \
			$PRINTF '%s\n' "$SWARM_MSG_STATUS_ARG_INVALID" && \
			return 99
		local RET="$1"
		local value="$(swarm.str.status $RET)"

		swarm.print.border -e >&2
		swarm.print.text -e "$2" "$3" "" >&1

		# Adjust fixer according to X or TTY
		[[ -n "${XDG_CURRENT_DESKTOP:-${DESKTOP_SESSION:-$XAUTHORITY}}" ]] && \
			gui_fixer="7" || gui_fixer=7

		$PRINTF "$(swarm.print.goto $(( ${COLUMNS:-$(${TPUT:-\tput} cols)} / 2 * 2 - ${#SWARM_THEME_DATA[border-left]} - 2 - $gui_fixer  )))"  # Sehe keinen unterschied zw. 4 bis 7
		#$PRINTF "$(swarm.print.goto $(( $COLUMNS / 2 * 2 - ${#SWARM_THEME_DATA[border-left]} - 2 - $gui_fixer  )))"  # Sehe keinen unterschied zw. 4 bis 7
		$PRINTF "$value" >&1

		$doReturn && \
			$PRINTF "$(swarm.print.goto 0)" || \
			$PRINTF "$posEND\n"
		return $RET
	}
	swarm.str.filesize() { # [ -k -m ] FILE
	# Returns the filesize in bytes
	#
		local MODE="bytes"
		local VAR=""
		for opt in "${@}"
		do
			case "$opt" in
			"-k")	MODE="kilo" ; VAR="$opt" ; shift	;;
			"-m")	MODE="mega" ; VAR="$opt" ; shift	;;
			esac
		done
	# Action
		if [[ "$1" == "--" ]]
		then
			while read line
			do
				$FUNCNAME $VAR "$line"
			done
		else
			case "$MODE" in
			"bytes")
				${LS:-\ls} -l "$1"| $AWK -v Text="$SWARM_MSG_WORD_BYTES" '{print $5 " " Text  }'
				;;
			"kilo")
				${LS:-\ls} -l "$1" | $AWK -v Text="$SWARM_MSG_WORD_KILOBYTES"  '{print sum/1024 " " Text  }'
				;;
			"mega")
				${LS:-\ls} -l "$1" | $AWK -v Text="${SWARM_MSG_WORD_MEGABYTES}"  '{print $5/1024/1024 " " Text}'
				;;
			esac
		fi
	}
	swarm.str.dirlist() { # PATH
	# Print a list of a ll subdirs
	# Ignores .git
		local tmp=""
		cd "$1"
		$FIND -type d -print | while read line;do tmp="$PWD/$line" ; $ECHO "${tmp/\/\.\//\/}" ;done 2>/dev/null| $GREP -v '.git'
		cd "$OLDPWD"
	}
	swarm.str.dirsize() { # [ -k -m ] DIR
	# Prints "SIZE TYPE in DIR"
	# -k for kilobytes ; -m for megabytes
		local MODE=bytes
		local VAR=""
		for opt in "${@}"
		do
			case "$opt" in
			"-k")	MODE=kilo ; VAR="$opt" ; shift	;;
			"-m")	MODE=mega ; VAR="$opt" ; shift	;;
			esac
		done
	# Action
		if [[ "$1" == "--" ]]
		then
			while read line
			do
				$FUNCNAME $VAR "$line"
			done
		else
			case "$MODE" in
			"bytes")
				${LS:-\ls} -l "$1" | $AWK -v DIR="$1" -v Text="$SWARM_MSG_DIR_SIZE_IN_BYTES" '{sum=sum+$5} END {print sum " " Text " \t" DIR }'
				;;
			"kilo")
				${LS:-\ls} -l "$1" | $AWK -v DIR="$1" -v Text="$SWARM_MSG_DIR_SIZE_IN_KB"  '{sum=sum+$5} END {print sum/1024 " " Text " \t" DIR }'
				;;
			"mega")
				${LS:-\ls} -l "$1" | $AWK -v DIR="$1" -v Text="${SWARM_MSG_DIR_SIZE_IN_MB}"  '{sum=sum+$5} END {print sum/1024/1024 " " Text " \t" DIR }'
				;;
			esac
		fi
	}
	swarm.str.bool2str() { # [options] $?
	# Returns a string from a BOOL input
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#
		# Defaults
		#
			local caps #=false
			local CAPS #=false
			local mode #="yes"
			local out=""
			#echo " ---------- $@ ----------- "
		#
		# Catching Arguments
		#
			# A ':' after a char indicates that this option requires an argument
			# Get access to the passed value of the argument by using $OPTARG
			while getopts "cCdoty" opt
			do
			 	case ${opt} in
				"c")	caps=true
						shift	;;
				"C")	CAPS=true
						shift	;;
				"d")	mode="done"
						shift	;;
				"t")	mode="true"
						shift	;;
				"y")	mode="yes"
						shift	;;
				"o")	mode="on"
						shift	;;
			#	*)	echo opt $opt ; exit 99	;;
				esac
			done
			shift $(($OPTIND - 1))
		#
		# Display & Action
		# This also handles translations
		#
			case "${mode}" in
			"done")	case "$1" in
				0)	out="$SWARM_MSG_WORD_DONE"	;;
				1)	out="$SWARM_MSG_WORD_FAIL"	;;
				esac
				;;
			"true")	case "$1" in
				0)	out="$SWARM_MSG_WORD_TRUE"	;;
				1)	out="$SWARM_MSG_WORD_FALSE"	;;
				esac
				;;
			"on")	case "$1" in
				0)	out="$SWARM_MSG_WORD_ON"	;;
				1)	out="$SWARM_MSG_WORD_OFF"	;;
				esac
				;;
			"yes"|*)	case "$1" in
				0)	out="$SWARM_MSG_WORD_YES"	;;
				1)	out="$SWARM_MSG_WORD_NO"	;;
				esac
				;;
			esac

			# Show the output
			if ${CAPS:-false}
			then	$PRINTF "${out^^}"
			elif ${caps:-false}
			then	$PRINTF "${out^}"
			else	$PRINTF "$out"
			fi
	}
	swarm.str.num2char() { # NUM
	# Returns a letter string: a-z
	# Or: aa-az ba-bz, etc
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		num="$1"
		out=""
		# Quoting these echo's will break the output
		[ "$num" -gt 700 ] && \
			list=( $(builtin echo {a..z} {a..z}{a..z} {a..z}{a..z}{a..z} ))	|| \
			list=( $(builtin echo {a..z} {a..z}{a..z} )) 	# Be fast for letters in range..
		out="${list[$num]}"
		$PRINTF '%s\n' "$out"
	}
	swarm.str.num2roman() { # NUM
	# Returns NUM in roman letters
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		input="$1"	# input num
		output=""	# Clear output string
		len="${#input}"	# Initial length to count down
		U="\033[4m"	# Underscore, multiplies with 1000
		R="\033[0m"	# Resets the underscore
		roman_val() { # NUM one five ten
		# This sub does the basic 'roman' algorithm
		#
			N="$1"
			one="$2"
			five="$3"
			ten="$4"
			out=""
			case "$N" in
			0)	out+=""	;;
			[123])	while [ "$N" -gt 0 ]
				do	out+="$one"
					N="$(($N-1))"
				done
				;;
			4)	out+="$one$five"	;;
			5)	out+="$five"	;;
			[678])	out+="$five"
				N="$(($N-5))"
				while [ "$N" -gt 0 ]
				do	out+="$one"
					N=$(($N-1))
				done
				;;
			9)	while [ "$N" -lt 10 ]
				do	out+="$one"
					N="$(($N+1))"
				done
				out+="$ten"
				;;
			esac
			echo "$out"
		}
		while [ "$len" -gt 0  ]
		do	# There are letters to add
			num="${input:0:1}"
			# Do action according position
			case "$len" in
			1)	output+="$(roman_val $num I V X)"	;;
			2)	output+="$(roman_val $num X L C)"	;;
			3)	output+="$(roman_val $num C D M)"	;;
			4)	output+="$(roman_val $num M ${U}V${R} ${U}X${R})"	;;
			5)	output+="$(roman_val $num ${U}X${R} ${U}L${R} ${U}C${R})"	;;
			*)	# Count it up
				Tone="CI\)"
				Tfive="I\)"
				Tten="CCI\)\)"
				DEPTH="$(( $len - 3 ))"	# 1 = 1000 = initial template
				while [ "$DEPTH" -gt 1 ]
				do	Tone="C$Tone)"
					Tfive="C$Tfive)"
					Tten="C$Tten)"
					DEPTH="$(($DEPTH-1))"
				done
				output+="$(roman_val $num $Tone $Tfive $Tten  )"
				;;
			esac
			input="${input:1}" ; len="${#input}"
		done
		$PRINTF "$output"
	}
	swarm.str.num2ascii() { # NUM
	# Returns the ASCII of given NUM
	# https://www.unix.com/shell-programming-and-scripting/284185-problems-converting-decimal-ascii-back-decimal.html
		[[ -z "$1" ]] && return 1
		[[ $1 =~ ^[0-9]+$ ]] || return 1
		$PRINTF "\\$($PRINTF '%03o' "$1")"
	}
	swarm.str.ascii2num() { # "CHAR"
	# Returns the (ASCII-)NUM of given CHAR
	# https://www.unix.com/shell-programming-and-scripting/284185-problems-converting-decimal-ascii-back-decimal.html
		[[ $# -gt 1 ]] && return 1
		$PRINTF "%u\n" "'${1}"
	}
	printlist() { # [options] $LIST or ${ARRAYS[@]}
	# Prints up to 3 'indexed'/numbered entries per row
	# Options -12arn ; 1 or 2 rows (instead of 3=default), alpha, roman, num=default
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#
		# Variable defaults (options)
		#
			local MODE=none
			local SEP=""
			local ROWS=3
			local as_menu=false
		#
		# Catch arguments
		#
			for opt in "${@}"
			do 	# Only parse for Arguments
				# if variable:'opt' starts with '-'
				[[ "-" == "${opt:0:1}" ]] && \
					case "${opt/-}" in
					"1" | "2" | "3")
						ROWS="${opt/-}"
						shift
						;;
					"0")	as_menu=true
						shift
						;;
					"a")	MODE=alpha
						SEP=") "
						shift
						;;
					"r")	MODE=roman
						SEP=". "
						shift
						;;
					"n")	MODE=num
						SEP=") "
						shift
						;;
					esac
			done
			[ -z "$1" ] && \
				while IFS= read -r ARG
				do	set -- "$@" "$ARG"
				done
			ARGS=( "${@}")
			# Update geometry
			swarm.update.geometry
		#
		# Action
		#
			unset OUT[@]
			OUT[0]=""
			local shown=false
			local MAX="$(( $ROWS - 1 ))"
			local CUR=0
			local DONE=0
			local count=""
			for OPT in "${ARGS[@]}"
			do	$as_menu || DONE="$(( $DONE + 1))"
				# Do the visible counter
				case "$MODE" in
				num)	count="$DONE"
					;;
				alpha)	count="$(swarm.str.num2char $(( $DONE - 1 )) )"
					;;
				roman)	count="$(swarm.str.num2roman $DONE)"
					;;
				esac

				# Add the string to array, or print array
				if [ "$CUR" -le "$MAX" ]
				then	len=0
					for O in "${OUT[@]}";do len=$[ $len + ${#O} ];done
					sum="$(( $len + 2  + ( ${#BORDER_LEFT} * 2 ) ))"

					if [ "$sum" -lt "$COLUMNS" ]
					then	OUT["$CUR"]="${count}${SEP}${OPT}"
						shown=false
						CUR="$(( $CUR + 1 ))"
					else	printe  "${OUT[@]}" >&2
						CUR=0 && unset OUT[@]
						[ -z "$OPT" ] && shown=true
						OUT["$CUR"]="${count}${SEP}${OPT}"
						CUR="$(( $CUR + 1 ))"
					fi
				else 	printe  "${OUT[@]}" >&2
					CUR=0 && unset OUT[@]
					[ -z "$OPT" ] && shown=true
					OUT["$CUR"]="${count}${SEP}$OPT"
					CUR="$(( $CUR + 1 ))"
				fi
				$as_menu && DONE="$(( $DONE + 1))"
			done
		#
		# Display
		#
			! $shown && printe  "${OUT[@]}" >&2
			return 0
	}
	pick() { # [-1 -2 -a -m] $LIST or ${ARRAYS[@]}
	# Select an item of a LIST or an ARRAY, that will be returned
	# Use -a for autoselect if only 1 entry, and -m as this will present 'Back' (translated)
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#
		# Variables
		#
			local counter=0
			local AUTO=false
			local ROWS="3"
			local as_menu=false
		#
		# Catch arguments
		#
			for opt in "${@}"
			do	if [[ "-" == "${opt:0:1}" ]]
				then	case "${opt/-}" in
					1|2|3)	ROWS="${opt/-}"
						shift
						;;
					"a")	AUTO=true
						shift
						;;
					"m")	trap "return 130" INT ABRT KILL
						as_menu=true
						shift
						;;
					esac
				fi
			done
			# Can not be set earlier because of possible options
			# Which state wether it is 'as menu' or default
			$as_menu && \
				local ARGS=( "${SWARM_MSG_WORD_BACK}" "${@}" ) || \
				local ARGS=("${@}")
		# Handle auto-pick (only 1 option)
			"$AUTO" && \
				[ "$#" -eq 1 ] && \
				$PRINTF '%s\n' "$ARGS" >&1 && \
				return 4
		# Show the items to pick from
			$as_menu && \
				printlist -n -$ROWS -0 "${ARGS[@]}" || \
				printlist -n -$ROWS "${ARGS[@]}"
		# Set dynamic values
			# Amount of arguments
			local pick_count=${#ARGS[@]}
			# Character length of the amount
			local pick_len=${#pick_count}
			# Special handling
			local invalid=true
			local todo=false
			local NUM=""
			local POS="$(swarm.print.goto $(( $identRight + 1 ))) ${SWARM_THEME_DATA[read]}"
			$as_menu && \
				local min=0 || \
				local min=1
		#
		# Visuals
		#
		while $invalid
		do
		# Print the input line:
			swarm.print.border >&2
			$PRINTF "$POS      $POS " >&2
		# Read the input
			builtin read -n $pick_len NUM
		# Catch invalid inputs
			# Keep reading if NUM is empty
			[[ -z "$NUM" ]] && continue
			# Check for arrow keys, and make sure NUM is numeric only : Thank you MIG
			[[ $NUM =~ ^[0-9]+$ ]] || continue
			# If it's exactly 0, it's BACK
			[[ ${NUM} -lt $pick_len ]] && todo=false #$PRINTF "\n" && $PRINTF "${ARGS[$NUM]}" >&1 && return 4
			# Keep reading if it is not greater than 'min'-imum
			[[ ${NUM} -ge $min ]] || continue
			# Check if the 0 index is missing
			$as_menu || NUM=$(( $NUM - 1))
			# Keep reading if it is greater than pick_count
			[[ $NUM -gt $pick_count ]] && continue
		# Exit the loop
			invalid=false
		done

		# Output
		$ECHO ${ARGS[$NUM]} >&1
		#set -x
		[[ ${#NUM} -lt ${pick_len} ]] || $PRINTF "${POS_END}\n" >&2
		#set +x
		unset opt
	}
	press() { # [-c -l -r] [STR]
	# Requires the user to press [Enter/Return] before script continues
	# c=center ,l=left , r=right
		# Vars
		local mode=""
		local doReturn=false
		# Catch arguments
		for opt in "${@}"
		do	if [[ "-" == "${opt:0:1}" ]]
			then	case "${opt:1}" in
				"c")	mode="center"
					shift
					;;
				"l")	mode="left"
					shift
					;;
				"r")	mode="right"
					shift
					;;
				#"R")	doReturn=true
				#	shift
				#	;;
				esac
			fi
		done
	# Display
		case "$mode" in
		"center")
			printl "" "${1:-$SWARM_MSG_PRESS_ENTER}" ""
			;;
		"left")
			printl "${1:-$SWARM_MSG_PRESS_ENTER}"
			;;
		"right")
			printl "" "" "${1:-$SWARM_MSG_PRESS_ENTER}"
			;;
		*)
			printl "${1:-$SWARM_MSG_PRESS_ENTER}" "" "${1:-$SWARM_MSG_PRESS_ENTER}"
			;;
		esac
	# Action :p
		#$doReturn && \
		#	$PRINTF "$(swarm.print.goto 0)" && \
		#	(var=$(builtin read -u buffer n0 2>/dev/null)) & || \
			builtin read
	}
	ask() { # "A question?"
	# Reads a user's input
	# Returns the buffer
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		hideText=""
		notEmpty=false
	# Catch options
		for opt in "${@}"
		do
			case "$opt" in
			"-n")
				notEmpty=true
				shift
				;;
			"-p")
				hideText="-s"
				shift
				;;
			esac
		done
	# Define the proper string to display
		[[ -z "$1" ]] && \
			local STR="$(swarm.print.goto $(( $identRight + 1 ))) ${SWARM_THEME_DATA[read]}" || \
			local STR="$(swarm.print.goto $(( $identRight + 1 ))) $1 ${SWARM_THEME_DATA[read]}"
	# Does it need a loop?
		if $notEmpty
		then
			while [[ -z "$buffer" ]]
			do
				swarm.print.border >&2
				$PRINTF "$STR " >&2
				builtin read $hideText buffer
			done
		else
			swarm.print.border >&2
			$PRINTF "$STR " >&2
			builtin read $hideText buffer
		fi
	# Output
		$ECHO "$buffer" >&1
	}
	edit() { # [ -c ] FILE1 FILE2 FILE3 ...
	#
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		local cli_forced=false
		local EDITOR=""
	# Get options
		for opt in "${@}"
		do
			case "${opt}" in
			"-c")
				cli_forced=true
				shift
				;;
			esac
		done
	# Prepare : first use or is variable set?
		if [[ -z "$EDITOR_GUI" ]]
		then
			title "$SWARM_MSG_EDITOR_GUI"
			list_raw="$(<${SWARM_DIR_LIST}/editor_gui)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			EDITOR_GUI=$(pick -a $list)
			cfg.set "$SWARMRC" "EDITOR_GUI" "${EDITOR_GUI##*/}"
			status $? "$SWARMRC" "EDITOR_GUI=${EDITOR_GUI##*/}"
		fi
		if [[ -z "$EDITOR_CLI" ]]
		then
			title "$SWARM_MSG_EDITOR_CLI"
			list_raw="$(<${SWARM_DIR_LIST}/editor_cli)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			EDITOR_CLI=$(pick -a $list)
			cfg.set "$SWARMRC" "EDITOR_CLI" "${EDITOR_CLI##*/}"
			status $? "$SWARMRC" "EDITOR_CLI=${EDITOR_CLI##*/}"
		fi

	# Prepare : Get the proper editor
		if ! $isGUI || $cli_forced
		then	# Its console, or forced
			[[ -n "$EDITOR_CLI" ]] && EDITOR="$EDITOR_CLI"
		else	# it is GUI
			[[ -n "$EDITOR_GUI" ]] && EDITOR="$EDITOR_GUI"
		fi
	# Action
		for F in "${@}"
		do
			$EDITOR "$F"
		done
	}
	filemgr() { # [ -c ] FILE1 FILE2 FILE3 ...
	#
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		local cli_forced=false
		local FILEMGR=""
	# Get options
		for opt in "${@}"
		do
			case "${opt}" in
			"-c")
				cli_forced=true
				shift
				;;
			esac
		done
	# Prepare : first use or is variable set?
		if [[ -z "$FILEMGR_GUI" ]]
		then
			title "$SWARM_MSG_FILEMGR_GUI"
			list_raw="$(<${SWARM_DIR_LIST}/filemgr_gui)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			FILEMGR_GUI=$(pick -a $list)
			cfg.set "$SWARMRC" "FILEMGR_GUI" "${FILEMGR_GUI##*/}"
			status $? "$SWARMRC" "FILEMGR_GUI=${FILEMGR_GUI##*/}"
		fi
		if [[ -z "$FILEMGR_CLI" ]]
		then
			title "$SWARM_MSG_FILEMGR_CLI"
			list_raw="$(<${SWARM_DIR_LIST}/filemgr_cli)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			FILEMGR_CLI=$(pick -a $list)
			cfg.set "$SWARMRC" "FILEMGR_CLI" "${FILEMGR_CLI##*/}"
			status $? "$SWARMRC" "FILEMGR_CLI=${FILEMGR_CLI##*/}"
		fi

	# Prepare : Get the proper editor
		if ! $isGUI || $cli_forced
		then	# Its console, or forced
			[[ -n "$FILEMGR_CLI" ]] && FILEMGR="$FILEMGR_CLI##*/}"
		else	# it is GUI
			[[ -n "$FILEMGR_GUI" ]] && FILEMGR="$FILEMGR_GUI##*/}"
		fi
	# Action
		# Sadly not all GUI filemanagers support tabs
		for F in "${@}"
		do
			$FILEMGR "$F"
		done
	}
	web() { # [ -c ] FILE1 FILE2 FILE3 ...
	#
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		local cli_forced=false
		local FILEMGR=""
	# Get options
		for opt in "${@}"
		do
			case "${opt}" in
			"-c")
				cli_forced=true
				shift
				;;
			esac
		done
	# Prepare : first use or is variable set?
		if [[ -z "$WEB_GUI" ]]
		then
			title "$SWARM_MSG_WEB_GUI"
			list_raw="$(<${SWARM_DIR_LIST}/web_gui)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			WEB_GUI=$(pick -a $list)
			cfg.set "$SWARMRC" "WEB_GUI" "${WEB_GUI##*/}"
			status $? "$SWARMRC" "WEB_GUI=${WEB_GUI##*/}"
		fi
		if [[ -z "$WEB_CLI" ]]
		then
			title "$SWARM_MSG_WEB_CLI"
			list_raw="$(<${SWARM_DIR_LIST}/web_cli)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			WEB_CLI=$(pick -a $list)
			cfg.set "$SWARMRC" "WEB_CLI" "${WEB_CLI##*/}"
			status $? "$SWARMRC" "WEB_CLI=${WEB_CLI##*/}"
		fi

	# Prepare : Get the proper editor
		if ! $isGUI || $cli_forced
		then	# Its console, or forced
			[[ -n "$WEB_CLI" ]] && WEB="${WEB_CLI}"
		else	# it is GUI
			[[ -n "$WEB_GUI" ]] && WEB="${WEB_GUI}"
		fi
	# Action
		# Sadly not all GUI filemanagers support tabs
		for F in "${@}"
		do
			$WEB "$F"
		done
	}
	terminals() {  ## # [ -c ] FILE1 FILE2 FILE3 ...
	#
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		local cli_forced=false
		local FILEMGR=""
	# Get options
		for opt in "${@}"
		do
			case "${opt}" in
			"-c")
				cli_forced=true
				shift
				;;
			esac
		done
	# Prepare : first use or is variable set?
		if [[ -z "$TERMINAL_GUI" ]]
		then
			title "$SWARM_MSG_TERMINAL_GUI"
			list_raw="$(<${SWARM_DIR_LIST}/terminal_gui)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			TERMINAL_GUI=$(pick -a $list)
			cfg.set "$SWARMRC" "TERMINAL_GUI" "${TERMINAL_GUI##*/}"
			status $? "$SWARMRC" "TERMINAL_GUI=${TERMINAL_GUI##*/}"
		fi

	# Prepare : Get the proper editor
		if ! $isGUI || $cli_forced
		then	# Its console, or forced
			[[ -n "$FILEMGR_CLI" ]] && FILEMGR="$FILEMGR_CLI"
		else	# it is GUI
			[[ -n "$FILEMGR_GUI" ]] && FILEMGR="$FILEMGR_GUI"
		fi
	# Action
		# Handle 'known' terminal emulators
		case "${TERMINAL_GUI:-$TERMINAL}" in
		gnome-terminal|lxterminal|vte|[eipx]term)
			[ -z "$1" ] && opt="" || opt="-e "	;;
		termit)
			[ -z "$1" ] && opt="" || opt="-c "	;;
		*)	# Handle 'unknown' terminal emulators, assuming defaults
			[ -z "$1" ] && opt="" || opt="-e "
			# Fill the fallback, to avoid empty calls
			TERMINAL="${TERMINAL:-xterm}"
			printe -E  "$(eval_gettext '$TERMINAL: Using default option \"$opt\", please report your terminal ($TERMINAL) and its command execution option.')" >&2
			;;
		esac
		# Sadly not all GUI filemanagers support tabs
		if [[ -f "$1" ]]
		then	# handle file
			$TERMINAL_GUI $opt "$@"
		else	# handle command
			$TERMINAL_GUI $opt "$@"
		fi
	}
	rnd() { #
	#
	#
		doPerm=false
		doList=false
		PERM_NUM=""
		LIST_NUM=""
		MIN=""
		MAX=""
		c=0
	# Catch Arguments
		case "$1" in
		"-p"|"--perm")
			doPerm=true
			PERM_NUM="$2"
			# Permutation requires some calulations
			case $# in
			1|2)	# If 2, too many arguments, ignoring...
				MIN=$(( $1 ))
				MAX=$(( $1 + $PERM_NUM ))
				;;
			esac
			shift 2
			;;
		"-l"|"--list")
			doList=true
			LIST_NUM="$2"
			shift 2
			;;
		esac
		case $# in
		0)	MIN=${MIN:-1}
			MAX=${MAX:-100}
			;;
		1)	MIN=${MIN:-1}
			MAX=${MAX:-$1}
			;;
		2)	MIN=${MIN:-$1}
			MAX=${MAX:-$2}
			;;
		esac
	# Functions
		myRND() { #
		#
		#
			VAR=$[ $RANDOM % $MAX ]
			while  [[ $VAR -lt $MIN ]] || [[ $VAR -gt $MAX ]]
			do	VAR=$[ $RANDOM % $MAX ]
				# This is required, otherwise one never gets the 'max' value.
				VAR=$(( $VAR + 1 ))
			done
			builtin echo "$VAR"
		}
	#
	#	Display & Action
	#
	#
		if $doList
		then	declare -A L
			while [[ $c -lt $LIST_NUM ]]
			do
				n=$(myRND)
				while echo "${L[@]}" | $GREP -q $n
				do	n=$(myRND)
				done
				L[$c]=$n
				((c++))
			done
			echo "${L[@]}"
			unset L
		elif $doPerm
		then 	# This part (permutation) is originaly from RupertPumpkin
			# http://forums.fedoraforum.org/showpost.php?p=1748816&postcount=6
			# but has been modified by sea to match this command functionality
			declare -A P
			R=$RANDOM
			for x in $(eval builtin echo {${MIN}..${MAX}})
			do
				while 	[[ -n "${P[$R]}" ]]
				do	R=$RANDOM
				done
				P[$R]="$x"
			done
			echo "${P[@]}"
			unset P
		else	myRND
		fi
		#set +x
	}
	swarm.str.seconds2TIME() { # --> NEW ONE
	# Returns the TIME as string
	# as much as applicable: hh:mm:ss
		local tmp_input="${1:-0}"
		local tmp_work="$tmp_input"

		local M=60
		local H=3600
		# display
		local hours=0
		local minutes=0
		local seconds=0
		# subtraction
		local sub_hrs=0
		local sub_min=0


		# Get hours
		while [[ $tmp_work -ge $H ]]
		do
			((hours++))
			tmp_work=$(( $tmp_work - $H ))
		done
		# Get minutes
		while [ $tmp_work -ge $M ]
		do
			((minutes++))
			tmp_work=$(( $tmp_work - $M ))
		done
		seconds=$tmp_work


		# Format strings - hrs
		[[ $hours -eq 0 ]] && \
			hours="0" || hours+=":"

		# Format strings - mins
		if [[ ${hours/:} -eq 0 ]] && [ ${minutes/:} -eq 0 ]
		then	minutes="0"
		elif [[ ${hours/:} -gt 0 ]]
		then	[[ ${#minutes} -lt 2 ]] && \
				minutes="0${minutes}:" || \
				minutes+=":"
		else	minutes+=":"
		fi

		# Format strings - secs
		if [[ ${hours/:} -gt 0 ]] || [[ ${minutes/:} -gt 0 ]]
		then	[[ ${#seconds} -lt 2 ]] && \
				seconds="0${seconds}"
		fi

		# Remove the single '0', as they were only required to be 'math compatible'
		[[ "$hours" = "0" ]] && hours=""
		[[ "$minutes" = "0" ]] && minutes=""


		builtin echo "${hours}${minutes}$seconds"
	}
	wait() { # NUM{s,m,h} [MSG]
	# Counts down from passed NUM, if neither 'm' nor 'h' is passed, it assumes seconds.
	#
		local beVerbose=false
	# Catch options
		for opt in "${@}"
		do
			case "${opt}" in
			"-v")
				beVerbose=true
				shift
				;;
			esac
		done

		TIME="${1/[a-zA-Z]}"
		UNIT="$(builtin echo ${1}|$TR -d [:digit:])"
		[[ -z "$UNIT" ]] && UNIT="s"

		#set -x
		if [[ "$1" == "$TIME$UNIT" ]]
		then	# all Good
			builtin echo >/dev/null
		else
			builtin echo "$SWARM_MSG_WAIT_USAGE"
			return 1
		fi
		if [[ -z "$UNIT" ]]
		then	if [[ -z "$TIME" ]]
			then
				builtin echo "$SWARM_MSG_WAIT_USAGE"
				return 1
			fi
			if ! builtin echo "${UNIT:-s}"|${GREP:-grep} -v ^[smh]
			then
				builtin echo "$SWARM_MSG_WAIT_FAIL"
				return 1
			fi
		fi
		#set +x

		[[ -z "$2" ]] && \
			MSG="$SWARM_MSG_WAIT_TIME_LEFT" || \
			MSG="$2"
		case ${UNIT,,} in
		s)	seconds="$TIME"	;;
		m)	minutes="$TIME"	;;
		h)	hours="$TIME"	;;
		*)	status 1 "$SWARM_MSG_WAIT_USAGE"
			return $?
			;;
		esac

		case "${UNIT,,}" in
		s)	seconds_total="$TIME"	;;
		m)	seconds_total="$(( 60 * $TIME ))"	;;
		h)	seconds_total="$(( 60 * 60 * $TIME ))"	;;
		esac
	#
	#	Action - loop
	#
		seconds_total="${seconds_total//\/}"
		while [ $seconds_total -ge 0 ]
		do 	# Get total TIME string and subtract 1 second
			TIME_string="$(swarm.str.seconds2TIME $seconds_total)"
			((seconds_total--))

			# Display to user
			swarm.print.border
			swarm.print.text -p  "${2:-$MSG}" " " "$TIME_string"

			# Wait
			sleep 1  # 0.999

			# Verbose / Countdown?
			if ${beVerbose}
			then	[[ $seconds_total -lt 0 ]] ||\
					$PRINTF "\n"
			fi

		done
		$PRINTF "\n"
		return 0
	}
	bar()  { # [options] [MESSAGE]
	# Prints a progress bar
	#
		# internals
		local TYPE=""		# Start with no display mode
		local INDI=(  '/' '-' '\' '|' )	# Dont use tui-indi, for asynchronus display
		local TOTAL=$[ ${#INDI[@]} -1 ]
		#WIDTH=${COLUMNS:-$(tput cols)}
		# id file?
		local ID_CUR="$$"	# -i ID storage id
		local ID=""		# -i ID storage id
		# bols
		local CLEARLINE=false	# Clear line between display calls?
		local hadOpts=false	# Shift only if it had opts
		local doReset=false	# Reset the ID file?
		local doBar=false
		local longBar=false	# Show (& calc) the STATUS (procent)
		local hasID=false
		# opts
		local MAX=""
		local VAL #="1"		# This is used as index for the dash animation
		local CURRENT=""
		#local BAR='='
		# Display
		local PROGRESS=""
		local STATUS=""
		local MESSAGE=""
		local STR_COLORS_RAW
		# This should not be required
		#swarm.update.geometry
	#
	#	Functions
	#
		function bar.simple_status() {
		# Generates a single string to represent the actual task/case
		#
			tmp=""
			[ ! -z "$MAX" ] && tmp="NUM"
			$doBar && [ ! -z "$MAX" ] && tmp="BAR"
			builtin echo "${tmp:-DASH}"
		}
		function bar.reset_tmp() { # ID
		# Resets the counter according to passed ID
		# Needs to be one, otherwise last item is too low
			if "$hasID"
			then	SWARM_PROGRESS_BAR_IDS[$ID]=1
			else	SWARM_PROGRESS_BAR_IDS[$ID_CUR]=1
			fi
			export SWARM_PROGRESS_BAR_IDS
		}
		function bar.save_tmp() { # VAL
		# Saves VAL in the temp file according to passed id
		#
			[ -z "$1" ] && return 1
			if "$hasID"
			then	SWARM_PROGRESS_BAR_IDS[$ID]="$1"
			else	SWARM_PROGRESS_BAR_IDS[$ID_CUR]="$1"
			fi
			export SWARM_PROGRESS_BAR_IDS
		}
		function bar.read_tmp() {
		# Reads VAL in the temp file according to passed id
		# Returns VAL
			if "$hasID"
			then	builtin echo "${SWARM_PROGRESS_BAR_IDS[$ID]}"
			else	builtin echo "${SWARM_PROGRESS_BAR_IDS[$ID_CUR]}"
			fi
		}
	#
	#	Catching Arguments
	#
		while : #for opt in "${@}" #while getopts "c:CB:bi:lm:rh" name
		do 	case $1 in
			-B)	BAR="$2"
				hadOpts=true
				;;
			-b)	doBar=true
				;;
			-c)	VAL="$2"
				hadOpts=true
				;;
			-C)	CLEARLINE=true
				;;
			--color)
				STR_COLORS_RAW="$2"
				# Vars
				local c=0
				local str_color str_num
				declare -ag SWARM_BAR_COLORS
				declare -ag SWARM_BAR_VALUE
				# Parse values
				while read item
				do
					str_color="$(builtin echo ${item} | $TR -d [:digit:])"
					str_value="$(builtin echo ${item} | $TR -d [:alpha:])"
					SWARM_BAR_COLORS=($str_color)
					SWARM_BAR_VALUE=($str_value)
					c=$(( $c + 1 ))
				done<<<$(builtin echo "$STR_COLORS_RAW" | $SED s/','/'\n'/g )
				hadOpts=true
				;;
			-i)	ID="$2"
				hasID=true
				hadOpts=true
				;;
			-p)	longBar=true
				;;
			-m)	MAX="$2"
				hadOpts=true
				;;
			-r)	doReset=true
				;;
			--) 	shift ; break ;;
			--help|-?)
				swarm.help.usage $FUNCNAME
				return "${RET_HELP:-99}"
				;;
			*)	break ;;
			esac
			$hadOpts && \
				shift 2 || \
				shift 1 #$(($OPTIND - 1))
			hadOpts=false
		done

	#
	#	Check for all required options
	#
		MESSAGE="$1"
		TYPE=$(bar.simple_status)
		VAL="${VAL:-$(bar.read_tmp)}"
	#
	#	Something quick?
	#
		$doReset && bar.reset_tmp && VAL="$(bar.read_tmp)"
		[[ -z "$VAL" ]] && VAL=1 && bar.reset_tmp
	#
	#	Prepare required tasks from options
	#
		case "${TYPE^^}" in
		DASH)
			bar.save_tmp "$(( $VAL + 1 ))"
			;;
		BAR)
			if [ -z "$MAX" ] || [ -z "$VAL" ]
			then	# Improper handling
				swarm.help.usage $FUNCNAME
				#tui-status 1 "$(eval_gettext 'Usage: $ME [-r] [-m \$MAV_VALUE]  [-bc \$CUR_VALUE] [-l]]  \"msg\"')"
				#exit 1
			fi
			bar.save_tmp "$(( $VAL + 1 ))"
		esac
	#
	#	Generate output string, and save values
	#
		#swarm.update.geometry
		POS=""
		case "${TYPE}" in
		DASH)	# Regular animated dash
			[[ "$VAL" -gt 3 ]] && VAL=0
			n=$(( $WIDTH - ${#BORDER_LEFT} - 8 ))
			POS="\033[${n}G"
			POS=""

			case $VAL in
			0|1|2)	STATUS="${POS}[  ${INDI[$VAL]}   ]"	;;
			# Below is a failback setting (injection protection)
			3)	#source "$SWARM_DIR_THEMES/${SWARM_THEME:-default-blue}"
				#STATUS="${POS}${STATUS}"
				STATUS=$($PRINTF "${POS}[  \174   ]")
				;;
			esac
			;;
		NUM)	# Show increments number
			[ $VAL -gt $MAX ] && \
				swarm.help.usage $FUNCNAME
				#echo "$(eval_gettext '$ME: Should have called \"${TUI_FONT_BOLD}$ME -r\" first!${TUI_FONT_RESET}')" >&2
			STATUS="[ $VAL / $MAX ]"
			;;
		BAR)	# Show pro-cent only if wanted
			fixer_fix=0
			if "$longBar"
			then	# Show also procent ($STATUS)
				procent="$( builtin echo $MAX $VAL | $AWK '{print (100/$1*$2) }' )"
				[ -z "$MESSAGE" ] && fixer_fix=0 || fixer_fix=5	# Does this depend on $WIDTH?

				# How many procent?
				pro="${procent/.*/}"
				[ "$pro" -gt 100 ] && \
					pro=100
				[ "$pro" -ne 100 ] && \
					cent="$( while IFS='.' read P C;do [ -z "$C" ] && builtin echo 00 || builtin echo $C;done<<<$procent)" && \
					cent="${cent:0:2}" || \
					cent=00
				case ${#pro} in
				1)	fixer=13 ;;
				2)	fixer=14 ;;
				3)	fixer=15 ;;
				esac
				length=$(( $numEND - (2 * ${#BORDER_LEFT}) - 2 - ${#MESSAGE} - 5 - ${fixer} - $fixer_fix  ))
				#STATUS="[ ${pro}.${cent}%% ]"		# Nope
				STATUS="[ ${pro}.${cent}%% ]"	# Ok, what?
				len=$( builtin echo $length $procent | $AWK '{print ($1/100*$2) }' )
			else	STATUS=""
				[ -z "$MESSAGE" ] && fixer_fix=7	# Does this depend on $WIDTH?
				# The length that is available to print bars
				[ -z "$MESSAGE" ] && \
					fixer=16 || \
					fixer=14
				length=$(( $numEND - (2 * ${#BORDER_LEFT}) - 2 - ${#MESSAGE} - ${fixer} - $fixer_fix ))
				len=$( echo $length $MAX $VAL | $AWK '{print ($1/$2*$3) }' )
			fi
	#		echo "len: $len // length: $length // width: $WIDTH // numEND: $numEND"
			# Colorize?
			if [[ -z "$SWARM_BAR_COLORS" ]]
			then
				bars=$($PRINTF '%*s' ${len/.*})
				bars=$(builtin echo "$bars"|$SED s," ","\\$BAR",g)
			else
				local bars_counter=$(( $numEND - ( 2 * $identRight ) ))
				local bars_curret=0
				local arr_count=0
				local clr_now="${SWARM_BAR_COLORS[0]}"
				local clr_color="$(swarm.color.fg $clr_now)"
				local num_next="${SWARM_BAR_VALUE[0]}"
				bars=""
				while [[ $bars_curret -lt $bars_counter ]]
				do
					bars+="${clr_color}${BAR}${c_reset}"
					bars_curret=$(( $bars_curret + 1 ))
					[[ $num_next -lt $bars_curret ]] && \
						arr_count=$(( $arr_count + 1 )) && \
						clr_now="${SWARM_BAR_COLORS[$arr_count]}" && \
						clr_color="$(swarm.color.fg $clr_now)" && \
						num_next="${SWARM_BAR_VALUE[$arr_count]}"
				done
			#	set +x
			fi
			bar_total="$($PRINTF '%*s' ${length/.*})"
			bar_total="[${bars}${bar_total:${#bars}}]"
			PROGRESS="$bar_total"
			;;
		#	*)	tui-status 1 "Error, type ($TYPE) is unhandled"	;;
		esac
		#[ -z "$PROGRESS" ] && printe -S 1 "Something went terrible wrong..." && exit 1
	#
	#	Display & Action
	#
		$CLEARLINE && $PRINTF "\e[2K"
		swarm.print.border
		case "${TYPE^^}" in
		NUM)
			swarm.print.text "$MESSAGE" "" "$STATUS"
			;;
		DASH)
			swarm.print.text "$MESSAGE" "" "$STATUS"
			VAL=$(( $VAL + 1 ))
			if [[ "${TYPE^^}" == "DASH" ]]
			then
				[[ $VAL -ge 4 ]] && VAL=1
			fi
			bar.save_tmp $VAL
			;;
		BAR)	if $longBar
			then	if [[ -z "$MESSAGE" ]]
			 	then	# No message
					#set -x
				#	printf "$posLEFT${PROGRESS}"
				#	num=$(( $posEND - $identRight - ${#STATUS} ))
				#	printf "$(swarm.print.goto $num)$STATUS"
					#set +x
					swarm.print.text "$PROGRESS" "" "$STATUS"
				else 	# With message
					swarm.print.text "$MESSAGE" "" "${PROGRESS}${STATUS}"
				fi
			else	if [[ -z "$MESSAGE" ]]
				then 	# No message
					printf "$posLEFT${PROGRESS}"
					printf "\n"
				else 	# With message
					swarm.print.text "$MESSAGE" "" "${PROGRESS}"
				fi
			fi
			;;
		esac
	}
	swarm.str.extension() { # FILENAME
	# Returns the file extension of a given FILENAME
	# REturns empty if no extension was found
		local ext="${1##*.}"
		# Tar is the only (known to me) file extension with 2 strings
		local TAR=""
		# Workaround for tarballs...
		builtin echo "$1" | $GREP -q ".tar" && \
			TAR="tar." || TAR=""
		if [ "$ext" = "$1" ]
		then	builtin echo ""
		else 	builtin echo "$TAR$ext"
		fi
	}
	swarm.str.genfilename() { # FILENAME.EXT [NEXT_EXT]
	# Prints the filename with an increased index before [NEW_]EXT
	#
		local this="$1"	# File without EXT?
		local EXT=$(swarm.str.extension "$this")	# OLD
		local ext="${2:-$EXT}"	# Fill 'ext' with old EXT if its empty
		this="${this%%$EXT}"
	#
	#	Action & Display
	#
		# Set the initial name check according to presets:
		# Currently only known special case: tar
		local NAME_INIT="${this/\.tar/}.$ext"
		NAME_INIT="${NAME_INIT/\.\./\.}"
		if [ -f "${NAME_INIT}" ]
		then	C=0		# Counter
			local NAME_CHECK="${this/\.tar}.$C.$ext"
			NAME_CHECK="${NAME_CHECK/\.\./\.}"
			while [ -f "${NAME_CHECK}" ]
			do	C=$(( $C + 1 ))
				NAME_CHECK="${this/\.tar}.$C.$ext"
				NAME_CHECK="${NAME_CHECK/\.\./\.}"
			done

			# Finally a file that does not exist yet
			builtin echo "$NAME_CHECK" >&1
		else	# File does not exist, and can be used
			builtin echo "$NAME_INIT"  >&1
		fi
	}
	swarm.str.usb() { #
	#
	#
		swarm.str.usb.getspace() { # NUM
		# Returns string of NUM space chars
		#
			local C=0
			local out=""
			while [[ "$C" -lt "$1" ]];do out+=" ";let C++;done
			printf "$out"
		}
		swarm.str.usb.getlist() { #
		# Lists the contend of $devDisk, limits the output to usb items and removes partition entries
		# If there is something to ignore, that one will be hidden too
			if [[ -z "$usbIgnore" ]]
			then	"$LS" "$devDisk" | "$GREP" usb | "$GREP" -v part
			else	"$LS" "$devDisk" | "$GREP" usb | "$GREP" -v part | "$GREP" -v "$usbIgnore"
			fi
		}
	# Variables
		# Make sure there is something available
		local msg="$SWARM_MSG_USB_CONNECT"
		local left="$BORDER_LEFT $msg"
		local list=""
		local sleeper=0.0001
		local targetusb=""
		local devDisk=/dev/disk/by-id
		local tDev=""
		local AUTO=false
	# Catch options
		for opt in "${@}"
		do
			case "${opt}" in
			"-a")
				AUTO=true
				;;
			esac
		done
	# Loop while waiting for --item-list-without-the-ignored-ones--
		while [[ -z "$list" ]] ; do
			bar "$msg" >&2
			list="$(getlist)" 2>/dev/null
			list="${list/$usbIgnore}"
			sleep $sleeper
			[[ "$sleeper" = "0.0001" ]] && sleeper=1.2
		done
	#
	#	Check for user settings for default behaviour.
	#	This is required so internal card readers do not get in the way,
	#	or so you can select to (not) use it automatically
	#
		#echo "if [ "$(echo $list|wc -l)" -eq 1 ] && [ -z "$usbAsk" ] "
		if [[ "$(builtin echo $list|$WC -w)" -eq 1 ]] && [[ -z "$usbAsk" ]]
		then	# There is no setting yet, first time usage
			printe  "$SWARM_MSG_USB_ONLY_AVAIL : ${list}" >&2
			if yesno "$SWARM_MSG_USB_CARD_LISTED" >&2
			then	if yesno "$SWARM_MSG_USB_CARD_IGNORE" >&2
				then	# Save the card reader
					cfg.set -v "$TUI_FILE_USER_SETTINGS" usbIgnore "\"$list\""
					RET=1
				else	printe  "$SWARM_MSG_USB_ASK_AGAIN" >&2
					yesno "$SWARM_MSG_USB_ASK_DESC" >&2
					RET=$?
				fi
			else	RET=1
			fi
			cfg.set -v "$TUI_FILE_USER_SETTINGS" usbAsk "$(swarm.str.bool2str -t $RET)"  >&2
			source "$TUI_FILE_USER_SETTINGS"
			[ -z "$usbIgnore" ] || return 1
		fi
	#
	#	Ask now or not?
	#
		if ${usbAsk:-true}
		then	"$AUTO" && \
				targetUsb="$(pickt -a $list)" || \
				targetUsb="$(pick $list)"
		else	targetUsb="$(pick -a $list)"
		fi
		tDev="$(readlink -f $devDisk/$targetUsb)"
		builtin echo "$tDev" >&1
	}
	swarm.fs.get_waiting() { # KILOBYTES
	# Returns the amount of seconds to wait
	#
		[[ -z "$1" ]] && builtin echo 0.3 && return
		if [[ $1 -lt 1000100 ]]
		then	# Its less than 1 mb
			waiting=0.1
		elif [[ $1 -lt 100100100 ]]
		then	# Its less than 100 mb
			waiting=0.3
		elif [[ $1 -lt 1000100100 ]]
		then	# Its less than 1 gb
			waiting=0.4
		elif [[ $1 -lt 10100100100 ]]
		then	# Its less than 10 gb
			waiting=0.5
		else	# for everything higher
			waiting=0.9
		fi
		builtin echo $waiting
	}
	swarm.util.cp() { # [-f -l -q -t TARGET] SOURCE [TARGET]
	# Copies SOURCE to TARGET
	# Returns 1 if TARGET-dir does not exist
		[[ -z "${@}" ]] && swarm.help.usage "$FUNCNAME" && return 1
		#local force_Overwrite=false
		local show_Longnames=false
		local cp_target=""
		local beVerbose=true
		local optargs=""
	# Catch arguments
		for opt in "${@}"
		do	case "${opt}" in
			"-f") 	#force_Overwrite=true
				optargs="-f"
				shift
				;;
			"-l")	show_Longnames=true ; shift	;;
			"-t")	cp_target="$2" ; shift 2	;;
			"-q")	beVerbose=false ; shift		;;
			"--")	# Do Pipe
				[[ -z "$cp_target" ]] && \
					swarm.help.manpage $FUNCNAME && \
					return 1
				while read line
				do
					\cp $optargs "$line" "$cp_target"
				done
				return 0
				;;
			*)	[[ "-" = "${opt:0:1}" ]] && \
					optargs+=" $opt" && shift	;;
			esac
		done
	# Make sure target is set
		local ARGS=("${@}")
		# If TARGET was not passed as option,
		# take last argument for it
		if [[ -z "$cp_target" ]]
		then
			local tID=$(( ${#ARGS[@]} - 1 ))
			cp_target="${ARGS[$tID]}"
			unset ARGS[$tID]
		fi
	# Preparations
		local MAX="${#ARGS[@]}"
		local COUNT=0
		#[[ -d "$cp_target" ]] || [[ -f "$cp_target" ]]

	# Action
		if $beVerbose
		then	# Show each file on its own line
			for src in "${ARGS[@]}"
			do
				$show_Longnames && src_show="$src" || src_show="${src##*/}"
				bar -m $MAX -c $COUNT "$SWARM_MSG_WORD_COPYING : $src"
				\cp $optargs "$src" "$cp_target"
				#$PRINTF "$POS_END\n"
				status -c $? "$SWARM_MSG_WORD_COPIED $SWARM_MSG_WORD_FILE: $cp_target"
				COUNT=$(( $COUNT + 1 ))
			done
		else	# Show all in one line;
			bar "$SWARM_MSG_WORD_COPYING $SWARM_MSG_WORD_FILES"
			\cp $optargs "${ARGS[@]}" "$cp_target"
			#$PRINTF "$POS_END\n"
			status $? "$SWARM_MSG_WORD_COPIED $MAX $SWARM_MSG_WORD_FILES"
		fi
	}
	download() { # [-f|--full] [-c] [-s] [-o FILENAME] [-d|--dir DIR] URL [URL2 ... URL99 ...]
	#
	#
		#ME="$FUNCNAME"
		swarm.protect "$@" && exit 1
		#set -x
	#	Created: 2013.09.13
	#	Changed:2015.11.07
	#	TUI -> SWARM: 2021.01.03
	#
	#
	#	Variable defaults
	#
		script_version=0.9.2
		DIR_TEMP="${SWARM_TMP_DIR:-${TMPDIR:-${HOME:-/root}/.cache}}"
		FILE_TEMP="$DIR_TEMP/swarm.download.$$.status"
		FILE_CMD="$DIR_TEMP/swarm.download.$$.cmd"
		DEST=""
		doShowFullPath=false
		str_fixed_output=""
		swarm.util.mkdir "$DIR_TEMP"  2>/dev/null
		LIST_APPS="wget curl"
		[ -z "$(which $CURLWGET 2>/dev/null)" ] && \
			CURLWGET="$(echo ${LIST_APP/$CURLWGET})"
		TERM="${TERM:-GNU\057Linux}"
		swarm.util.isDir "$DIR_TEMP"
		touch "$FILE_TEMP"
	#
	#	Messages
	#
		MSG_INIT_ACT="${SWARM_MSG_DOWNLOAD_INIT}..."
		MSG_ACT_ING="${SWARM_MSG_WORD_DOWNLOADING}..."
		MSG_ACT_ED="$SWARM_MSG_WORD_DOWNLOADED"
		MSG_NOTFOUND="$SWARM_MSG_INIT_CURLWGET_NFOUND"
		MSG_SELECT="$SWARM_MSG_DOWNLOAD_SELECT"
		MSG_INSTALL_ING="$SWARM_MSG_WORD_INSTALLING"
		MSG_INSTALL_ED="$SWARM_MSG_WORD_INSTALLED"
	#
	#	Argument handling
	#
		trap "RET=$?;rm -f $FILE_TEMP $FILE_CMD" INT ABRT QUIT KILL
		# Set empty default options:
		case "$CURLWGET" in
		*curl)	OPT_O="-o"
			#OPT_Q="-s"
			#OPT_C=""
			;;
		*wget)	OPT_O="-O"
			#OPT_Q="-q"
			#OPT_C="-c"
			;;
		esac
		# Catch options curl-wget crosswise
		while :;
		do
			case "$1" in
			-[oO])		str_fixed_output="$2"
					shift 2
					;;
			-[sq])		case "$CURLWGET" in
					curl)	OPT_Q="-s" ;;
					wget)	OPT_Q="-q" ;;
					esac
					shift
					;;
			"-c")		case "$CURLWGET" in
					curl)	OPT_C="" ;;
					wget)	OPT_C="-c" ;;
					esac
					shift
					;;
			"-d"|"--dir")	DEST="$1"
					shift
					;;
			"-f"|"--full")	doShowFullPath=true
					shift
					;;
			-*)		# Wrong option passed
					swarm.help.usage download
					return 0
					;;
			""|*tp:*)	# Proper handling, either URL or missing
					break ;;
			esac
		done
	#
	#	Verify there are URL's passed
	#
		ARGS=( "${@}" )
		# Exit script if nothing is passed to handle:
		[[ -z "${ARGS[*]}" ]] && \
			swarm.help.usage download && \
			return 1
	#
	#	Funcrtion
	#
		curl_get_filesize() {
		#
		#
			max_ret=$($AWK -vRS=$'\r' 'END{NR=3}END{print $2}' "$FILE_TEMP")
			case ${max_ret:(-1)} in
			G)	multi=$(( 1024 * 1024 * 1024 ))	;;
			M)	multi=$(( 1024 * 1024 ))	;;
			K)	multi=1024	;;
			B)	multi=1	;;
			esac

			max_val=$( echo "${max_ret:0:1}" "$multi" | awk '{ print ($1*$2)}' )
			echo ${max_val:-0}
		}
	#
	#	Action
	#
		for URL in "${ARGS[@]}"
		do 	THIS="${URL##*/}"
			# If DEST is given, prefix this, or use PWD if empty
			# However, the very first file might get a fixed output
			out_string="${str_fixed_output:-${DEST:-$PWD}}/$THIS"
			[[ -n "$str_fixed_output" ]] && str_fixed_output=""
			# How should it be displayed to the end user?
			$doShowFullPath && \
				str_File="$out_string" || \
				str_File="$THIS"
			# Does the file exist already?
			if [[ -f "$out_string" ]]
			then	# Overwrite, skip or new download?
				status 111 "$SWARM_MSG_PHRASE_FILE_EXISTS" "$out_string"
				# Let the user pick the action
				local tmp_val="$(pick $SWARM_MSG_WORD_SKIP $SWARM_MSG_WORD_OVERWRITE $SWARM_MSG_WORD_NEW)"
				# Now decide according to user selection
				case "$tmp_val" in
				"$SWARM_MSG_WORD_SKIP")
					status $RET_SKIP "$str_File"
					continue
					;;
				"$SWARM_MSG_WORD_NEW")
					out_string=$(swarm.str.genfilename "$out_string")
					THIS=$(swarm.str.genfilename "$THIS")
					$doShowFullPath && \
						str_File="$out_string" || \
						str_File="$THIS"
					;;
				esac
			fi

			# Initialize download - user output only
			status -r 2 "$MSG_INIT_ACT" #"$WORK"
			>$FILE_TEMP
			echo "LC_ALL=C $CURLWGET $OPT_C $OPT_O \"$out_string\" \"$URL\" 1>/dev/null 2>$FILE_TEMP" > "$FILE_CMD"
			chmod +x "$FILE_CMD"
			(
				"$FILE_CMD" 2>/dev/zero
			) & >/dev/zero 2>/dev/zero
			local lPID=$!

			str_left="$MSG_ACT_ING"
			str_middle="$THIS ($tmp_size)"	; len=${#str_middle}

			MAXVAL=$(curl_get_filesize)
			# While lPID found, assume its till downloading...
			while ps $lPID > /dev/zero #|$GREP $CURLWGET
			do	[[ -f "$THIS" ]] && \
					tmp_size="($($LS -hl |$GREP $THIS |$AWK '{print $5}'))"
				COLUMNS="$($TPUT cols)"
				str_middle="$THIS $tmp_size"
				[ 0 -ne "${MAXVAL:-0}" ] && \
					size_bar="$($LS -l |$GREP $THIS |$AWK '{print $5}')" \
					opt_bar="-b -m $MAXVAL -c $size_bar" || \
					opt_bar=""

				bar $opt_bar "$str_left ${str_middle}"
				sleep 1
				case ${CURLWGET,,} in
				curl*)	MAXVAL=$(curl_get_filesize)
					;;
				esac
			done
			sleep 0.5
			[[ -f "$out_string" ]]
			status $? "${MSG_ACT_ED}: ${str_File}"
		done
	}
