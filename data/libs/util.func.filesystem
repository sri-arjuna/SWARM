#!/usr/bin/env bash
swarm.fs.get_waiting() { # KILOBYTES
# Returns the amount of seconds to wait
#
	[[ -z "$1" ]] && $ECHO 0.3 && return
	if [[ $1 -lt 1000100 ]]
	then	# Its less than 1 mb
		waiting=0.1
	elif [[ $1 -lt 100100100 ]]
	then	# Its less than 100 mb
		waiting=0.3
	elif [[ $1 -lt 1000100100 ]]
	then	# Its less than 1 gb
		waiting=0.4
	elif [[ $1 -lt 10100100100 ]]
	then	# Its less than 10 gb
		waiting=0.5
	else	# for everything higher
		waiting=0.9
	fi
	$ECHO "$waiting"
}
swarm.util.cp() { # [-f -l -q -t TARGET] SOURCE [TARGET]
# Copies SOURCE to TARGET
# Returns 1 if TARGET-dir does not exist
	# shellcheck disable=SC2128
	[[ -z "${@}" ]] && swarm.help.usage "$FUNCNAME" && return 1
	#local force_Overwrite=false
	local show_Longnames=false
	local cp_target=""
	local beVerbose=true
	local optargs=""
# Catch arguments
	for opt in "${@}"
	do	case "${opt}" in
		"-f") 	#force_Overwrite=true
			optargs="-f"
			shift
			;;
		"-l")	show_Longnames=true ; shift	;;
		"-t")	cp_target="$2" ; shift 2	;;
		"-q")	beVerbose=false ; shift		;;
		"--")	# Do Pipe
			# shellcheck disable=SC2128
			[[ -z "$cp_target" ]] && \
				swarm.help.manpage "$FUNCNAME" && \
				return 1
			# shellcheck disable=SC2162
			while read line
			do
				# shellcheck disable=SC2086
				$CP $optargs "$line" "$cp_target"
			done
			return 0
			;;
		*)	[[ "-" = "${opt:0:1}" ]] && \
				optargs+=" $opt" && shift	;;
		esac
	done
# Make sure target is set
	local ARGS=("${@}")
	# If TARGET was not passed as option,
	# take last argument for it
	if [[ -z "$cp_target" ]]
	then
		local tID=$(( ${#ARGS[@]} - 1 ))
		cp_target="${ARGS[$tID]}"
		# shellcheck disable=SC2184
		unset ARGS[$tID]
	fi
# Preparations
	local MAX="${#ARGS[@]}"
	local COUNT=0
	#[[ -d "$cp_target" ]] || [[ -f "$cp_target" ]]

# Action
	if $beVerbose
	then	# Show each file on its own line
		for src in "${ARGS[@]}"
		do
			$show_Longnames && src_show="$src" || src_show="${src##*/}"
			bar -m "$MAX" -c "$COUNT" "$SWARM_MSG_WORD_COPYING : $src"
			# shellcheck disable=SC2086
			$CP $optargs "$src_show" "$cp_target"
			#$PRINTF "$POS_END\n"
			status -c $? "$SWARM_MSG_WORD_COPIED $SWARM_MSG_WORD_FILE: ${src_show} $SWARM_MSG_WORD_FROMTO_TO $cp_target"
			((COUNT++))
		done
	else	# Show all in one line;
		bar "$SWARM_MSG_WORD_COPYING $SWARM_MSG_WORD_FILES"
		# shellcheck disable=SC2086
		$CP $optargs "${ARGS[@]}" "$cp_target"
		#$PRINTF "$POS_END\n"
		status $? "$SWARM_MSG_WORD_COPIED $MAX $SWARM_MSG_WORD_FILES"
	fi
}
swarm.util.cd() { # DIR
#
#
	if [[ 1 -ne "${#@}" ]]
	then	# Expecting exactly 1 argument, anything else is wrong usage:
		swarm.help.usage "${FUNCNAME[@]}"
		return 1
	fi
	if [[ -d "$1" ]]
	then	cd "$1"
		return 0
	else	# Dir does not exist, what is wrong?
		title "${FUNCNAME[@]}: $1"
		if [[ "/" == "${1:0:1}" ]]
		then	# It does have a leading /
			printe "$SWARM_MSG_WORD_PASSED:" "$1"
			printe "$SWARN_MSG_WORD_EXPECTED:" "$1"
			if yesno "$SWARM_MSG_WORD_CREATE: $1"
			then 	if $MKDIR "$1"
				then	cd "$1"
				else 	status $? "$SWARM_MSG_PHRASE_COULDNOTCREATE:" "$1"
					return 1
				fi
				return 0
			else 	return 1
			fi
		else	# It is expecting a sub dir
			printe "$SWARM_MSG_WORD_PASSED:" "$1"
			printe "$SWARM_MSG_WORD_CURRENT $SWARM_MSG_WORD_DIR:" "$PWD"
			printe "$SWARN_MSG_WORD_EXPECTED:" "$PWD/$1"
			if yesno "$SWARM_MSG_WORD_CREATE: $PWD/$1"
			then 	if $MKDIR "$PWD/$1"
				then	cd "$1"
				else 	status $? "$SWARM_MSG_PHRASE_COULDNOTCREATE:" "$PWD/$1"
					return 1
				fi
				return 0
			else 	return 1
			fi
		fi
	fi
}
swarm.util.rm() { # FILE1 DIR2
# Deletes files and dirs recurisvly.
# Ask before removing a directory.
	if [[ -z "$1" ]]
	then	# Expecting at least one argument
		swarm.help.usage "${FUNCNAME[@]}"
		return 1
	fi
	local args="" msg="" rmAsk=false
	for item in "${@}"
	do
		rmAsk=false
		if [[ -f "$item" ]]
		then 	obj="$SWARM_MSG_WORD_FILE"
		elif [[ -L "$item" ]]
		then 	obj="$SWARM_MSG_WORD_FILE"
		elif [[ -d "$item" ]]
		then	# Ask in case of folders
			rmAsk=true
			obj="$SWARM_MSG_WORD_DIR"
			args="-fr"
		else	status 1 "$SWARM_MSG_PHRASE_FILENOTFOUND: $item"
			rmAsk=false
			continue
		fi
		if $rmAsk
		then	yesno "$SWARM_MSG_WORD_DELETE $obj: $item?" || continue
		fi
		msg="$SWARM_MSG_WORD_DELETED $obj $item"
		$RM_EXEC $args "$item"
		status $? "$msg" && init.log "$msg"
		RET=$(( RET + $? ))
	done
}
