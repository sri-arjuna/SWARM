#!/usr/bin/env bash
#
# Prepare functions
# that are supposed to be used by 'enduser' script authors
# Stuff like: yeno, pick, printe, header, title and 'all the rest'
#
#
# Visual outputs - 'End user' stuff
#
	header() { # LEFT CENTER RIGHT
	# This prints a full line in blue (default-back), with white (default-front) text
	# TODO long string adjustments TODO, uses script_{name,version} before it uses its SWARM counterparts
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		swarm.print.border -h
		case "$1" in
		"--default")
			shift
			#local today=`$DATE_TODAY`
			#local time=`$DATE_TIME`
			swarm.print.text -h \
				"${c_front}${c_back}${script_name:-SWARM} ${script_version:-${SWARM[VERSION]}-${SWARM[BUILD]}} ($(swarm.os.distro|$SED s,'"','',g))" \
				" " \
				"$($PRINTF '%s ' ${@}) | `$DATE_TODAY` / `$DATE_TIME`${c_reset}"
			#swarm.print.text -h \
			#	"${c_front}${c_back}${script_name:-SWARM} ${script_version:-${SWARM[VERSION]}-${SWARM[BUILD]}}" \
			#	" " \
			#	"$($PRINTF '%s ' ${@}) | ${today} / ${time}${c_reset}"
			;;
		*)
			swarm.print.text -h "${c_front}${c_back}$1" "$2" "$3${c_reset}"
			;;
		esac
		$PRINTF "$posEND\n"
	}
	title() { # Text
	# This prints a single centered string on a line
	# It has blue borders and fills the inner line with white (Default-{front,back})
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		swarm.print.border -t
		output="$1"
		#output=$(swarm.print.underline "$output")
		#output=$(swarm.print.bold "$output")
		swarm.print.text -t "${c_front}${c_back}${c_invert}${output}${c_reset}"
		$PRINTF "$posEND\n"
	}
	printe() { # [-|--] STR1 STR2 STR3
	# Simply prints the strings as passed, it requires 3 strings to use the center
	# For piping, it expects 3 lines, each representing 1 variable
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#set -x
		local MODE="none"
		# Get args
		case "$1" in
		"-1"|"-2")	MODE="${1/-}"
				shift
				;;
		*)		MODE="normal"
				;;
		esac
		# Get arg number if not forced yet
		[[ "normal" == "$MODE" ]] && [[ "-" != "$1" ]] && [[ "--" != "$1" ]] && MODE=${#@}
		# Get pipe?
		case "$1" in
		"--"|"-")
			case "$MODE" in
			"2")
				# Read pipe, expect 2 lines
				while read LEFT
				do
					read RIGHT
					printe "$LEFT" "" "$RIGHT"
				done
				return
				;;
			"1")
				# Read pipe, expect 1 lines
				while read LEFT
				do
					printe "$LEFT"
				done
				return
				;;
			*)
				# Read pipe, expect 3 lines (default)
				while read LEFT
				do
					read CENTER; read RIGHT
					printe "$LEFT" "$CENTER" "$RIGHT"
				done
				return
				;;
			esac
			;;
		esac
		#set +x
		case "$MODE" in
			"0")
				swarm.print.border -e
				swarm.print.text -e "" "" ""
				;;
			"1")
				swarm.print.border -e
				swarm.print.text -e "$1" "" ""
				;;
			"2")
				swarm.print.border -e
				swarm.print.text -e "$1" "" "$2"
				;;
			"3")
				swarm.print.border -e
				swarm.print.text -e "$1" "$2" "$3"
				;;
		esac
		$PRINTF "$posEND\n"
	}
	printl() { # STR1 STR2 STR3
	# Simply prints the strings as passed, stays on the same line
	# It requires 3 strings to use the center
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		local MODE="none"
		local ROW=3
		local doPipe=false
	# Get args
		for opt in "${@}"
		do
			case "${opt/-}" in
			"-1"|"-2")
				ROW="${1/-}"
				shift
				;;
			"-"|"")
				MODE="pipe"
				;;
			*)
				MODE="normal"
				;;
			esac
		done
	# Action
		case "$MODE" in
			"pipe")
				case "$ROW" in
				"2")
					# Read pipe, expect 2 lines
					while read LEFT
					do
						read RIGHT
						printe "$LEFT" "" "$RIGHT"
					done
					return
					;;
				"1")
					# Read pipe, expect 1 lines
					while read LEFT
					do
						printe "$LEFT"
					done
					return
					;;
				*)
					# Read pipe, expect 3 lines (default)
					while read LEFT
					do
						read CENTER; read RIGHT
						printe "$LEFT" "$CENTER" "$RIGHT"
					done
					return
					;;
				esac
				;;
			"normal")
				# Check if it makes sense to print the border
				[[ $COLUMNS -lt $SWARM_SKIP_THEME_WIDTH ]]
				swarm.print.border -e
				case "$ROW" in
					"0")

						swarm.print.text -e "" "" ""
						;;
					"1")
						swarm.print.border -e
						swarm.print.text -e "$1" "" ""
						;;
					"2")
						swarm.print.border -e
						swarm.print.text -e "$1" "" "$2"
						;;
					"3")
						swarm.print.border -e
						swarm.print.text -e "$1" "$2" "$3"
						;;
				esac
				;;
			"2")
				swarm.print.border -e
				swarm.print.text -e "$1" "" "$2"
				;;
			"3")
				swarm.print.border -e
				swarm.print.text -e "$1" "$2" "$3"
				;;
		esac
	}
#
# Visual outputs - 'End user' stuff - Core Convenience
#
	yesno() { # "What question?"
	# Ask a yes/no question, returns 0/true for yes and 1/false for no
	# y/n are taken from language file and are used in code
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		# Check if 'yesno' is empty, if so, fill with fallback values
		case "$1" in
		"--help"|"-h")
			swarm.help.screen "${SWARM_MSG_HELP_YESNO}"
			return 99
			;;
		esac
		[[ -z "${SWARM_MSG_YESNO_YES}${SWARM_MSG_YESNO_NO}" ]] && \
			SWARM_MSG_YESNO_YES="+" && \
			SWARM_MSG_YESNO_NO="-"

		swarm.print.border -e
		# Print the text
		$PRINTF "$(swarm.print.goto $(( ${#SWARM_THEME_DATA[border-left]} + 2  )))$1 (${SWARM_MSG_YESNO_YES:0:1}${SWARM_MSG_YESNO_NO:0:1})"
		# Move the cursor
		$PRINTF "$(swarm.print.goto $(( $COLUMNS / 2 * 2 - ${#SWARM_THEME_DATA[border-left]} - 2  )))"
		read -n1 answer
		$PRINTF "$posEND\n"

		case "$answer" in
		"+"|"${SWARM_MSG_YESNO_YES:0:1}")
				return 0
				;;
		"-"|"${SWARM_MSG_YESNO_NO:0:1}")
				return 1
				;;
		*)		return 1
				;;
		esac
	}
	status() { # $? ["Text Left"] ["Text Center"]
	# Prints text and exit with passed return code
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		unset RET TXT1 TXT2
		# Check for minimal arguments
		[[ -z "$1" ]] && \
			$PRINTF '%s\n' "$SWARM_MSG_STATUS_ARG_INVALID" && \
			return 99
		local RET="$1"
		local value="$(swarm.str.status $RET)"

		swarm.print.border -e >&2
		swarm.print.text -e "$2" "$3" "" >&1

		# Adjust fixer according to X or TTY
		[[ -n "${XDG_CURRENT_DESKTOP:-${DESKTOP_SESSION:-$XAUTHORITY}}" ]] && \
			gui_fixer="7" || gui_fixer=7

		$PRINTF "$(swarm.print.goto $(( ${COLUMNS:-$(${TPUT:-\tput} cols)} / 2 * 2 - ${#SWARM_THEME_DATA[border-left]} - 2 - $gui_fixer  )))"  # Sehe keinen unterschied zw. 4 bis 7
		#$PRINTF "$(swarm.print.goto $(( $COLUMNS / 2 * 2 - ${#SWARM_THEME_DATA[border-left]} - 2 - $gui_fixer  )))"  # Sehe keinen unterschied zw. 4 bis 7
		$PRINTF "$value" >&1

		$PRINTF "$posEND\n"
		return $RET
	}
	swarm.str.bool2str() { # [options] $?
	# Returns a string from a BOOL input
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#
		# Defaults
		#
			local caps #=false
			local CAPS #=false
			local mode #="yes"
			local out=""
			#echo " ---------- $@ ----------- "
		#
		# Catching Arguments
		#
			# A ':' after a char indicates that this option requires an argument
			# Get access to the passed value of the argument by using $OPTARG
			while getopts "cCdoty" opt
			do
			 	case ${opt} in
				"c")	caps=true
						shift	;;
				"C")	CAPS=true
						shift	;;
				"d")	mode="done"
						shift	;;
				"t")	mode="true"
						shift	;;
				"y")	mode="yes"
						shift	;;
				"o")	mode="on"
						shift	;;
			#	*)	echo opt $opt ; exit 99	;;
				esac
			done
			shift $(($OPTIND - 1))
		#
		# Display & Action
		# This also handles translations
		#
			case "${mode}" in
			"done")	case "$1" in
				0)	out="$SWARM_MSG_BOOL2STR_DONE"	;;
				1)	out="$SWARM_MSG_BOOL2STR_FAIL"	;;
				esac
				;;
			"true")	case "$1" in
				0)	out="$SWARM_MSG_BOOL2STR_TRUE"	;;
				1)	out="$SWARM_MSG_BOOL2STR_FALSE"	;;
				esac
				;;
			"on")	case "$1" in
				0)	out="$SWARM_MSG_BOOL2STR_ON"	;;
				1)	out="$SWARM_MSG_BOOL2STR_OFF"	;;
				esac
				;;
			"yes"|*)	case "$1" in
				0)	out="$SWARM_MSG_BOOL2STR_YES"	;;
				1)	out="$SWARM_MSG_BOOL2STR_NO"	;;
				esac
				;;
			esac

			# Show the output
			if ${CAPS:-false}
			then	$PRINTF "${out^^}"
			elif ${caps:-false}
			then	$PRINTF "${out^}"
			else	$PRINTF "$out"
			fi
	}
	swarm.str.num2char() { # NUM
	# Returns a letter string: a-z
	# Or: aa-az ba-bz, etc
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		num="$1"
		out=""
		# Quoting these echo's will break the output
		[ "$num" -gt 700 ] && \
			list=( $(builtin echo {a..z} {a..z}{a..z} {a..z}{a..z}{a..z} ))	|| \
			list=( $(builtin echo {a..z} {a..z}{a..z} )) 	# Be fast for letters in range..
		out="${list[$num]}"
		$PRINTF '%s\n' "$out"
	}
	swarm.str.num2roman() { # NUM
	# Returns NUM in roman letters
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		input="$1"	# input num
		output=""	# Clear output string
		len="${#input}"	# Initial length to count down
		U="\033[4m"	# Underscore, multiplies with 1000
		R="\033[0m"	# Resets the underscore
		roman_val() { # NUM one five ten
		# This sub does the basic 'roman' algorithm
		#
			N="$1"
			one="$2"
			five="$3"
			ten="$4"
			out=""
			case "$N" in
			0)	out+=""	;;
			[123])	while [ "$N" -gt 0 ]
				do	out+="$one"
					N="$(($N-1))"
				done
				;;
			4)	out+="$one$five"	;;
			5)	out+="$five"	;;
			[678])	out+="$five"
				N="$(($N-5))"
				while [ "$N" -gt 0 ]
				do	out+="$one"
					N=$(($N-1))
				done
				;;
			9)	while [ "$N" -lt 10 ]
				do	out+="$one"
					N="$(($N+1))"
				done
				out+="$ten"
				;;
			esac
			echo "$out"
		}
		while [ "$len" -gt 0  ]
		do	# There are letters to add
			num="${input:0:1}"
			# Do action according position
			case "$len" in
			1)	output+="$(roman_val $num I V X)"	;;
			2)	output+="$(roman_val $num X L C)"	;;
			3)	output+="$(roman_val $num C D M)"	;;
			4)	output+="$(roman_val $num M ${U}V${R} ${U}X${R})"	;;
			5)	output+="$(roman_val $num ${U}X${R} ${U}L${R} ${U}C${R})"	;;
			*)	# Count it up
				Tone="CI\)"
				Tfive="I\)"
				Tten="CCI\)\)"
				DEPTH="$(( $len - 3 ))"	# 1 = 1000 = initial template
				while [ "$DEPTH" -gt 1 ]
				do	Tone="C$Tone)"
					Tfive="C$Tfive)"
					Tten="C$Tten)"
					DEPTH="$(($DEPTH-1))"
				done
				output+="$(roman_val $num $Tone $Tfive $Tten  )"
				;;
			esac
			input="${input:1}" ; len="${#input}"
		done
		$PRINTF "$output"
	}
	swarm.str.num2ascii() { # NUM
	# Returns the ASCII of given NUM
	# https://www.unix.com/shell-programming-and-scripting/284185-problems-converting-decimal-ascii-back-decimal.html
		[[ -z "$1" ]] && return 1
		[[ $1 =~ ^[0-9]+$ ]] || return 1
		printf "\\$(printf '%03o' "$1")"
	}
	swarm.str.ascii2num() { # "CHAR"
	# Returns the (ASCII-)NUM of given CHAR
	# https://www.unix.com/shell-programming-and-scripting/284185-problems-converting-decimal-ascii-back-decimal.html
		[[ $# -gt 1 ]] && return 1
		printf "%u\n" "'${1}"
	}
	printlist() { # [options] $LIST or ${ARRAYS[@]}
	# Prints up to 3 'indexed'/numbered entries per row
	# Options -12arn ; 1 or 2 rows (instead of 3=default), alpha, roman, num=default
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#
		# Variable defaults (options)
		#
			local MODE=none
			local SEP=""
			local ROWS=3
			local as_menu=false
		#
		# Catch arguments
		#
			for opt in "${@}"
			do 	# Only parse for Arguments
				# if variable:'opt' starts with '-'
				[[ "-" == "${opt:0:1}" ]] && \
					case "${opt/-}" in
					"1" | "2" | "3")
						ROWS="${opt/-}"
						shift
						;;
					"0")	as_menu=true
						shift
						;;
					"a")	MODE=alpha
						SEP=") "
						shift
						;;
					"r")	MODE=roman
						SEP=". "
						shift
						;;
					"n")	MODE=num
						SEP=") "
						shift
						;;
					esac
			done
			[ -z "$1" ] && \
				while IFS= read -r ARG
				do	set -- "$@" "$ARG"
				done
			ARGS=( "${@}")
			# Update geometry
			swarm.update.geometry
		#
		# Action
		#
			unset OUT[@]
			OUT[0]=""
			local shown=false
			local MAX="$(( $ROWS - 1 ))"
			local CUR=0
			local DONE=0
			local count=""
			for OPT in "${ARGS[@]}"
			do	$as_menu || DONE="$(( $DONE + 1))"
				# Do the visible counter
				case "$MODE" in
				num)	count="$DONE"
					;;
				alpha)	count="$(swarm.str.num2char $(( $DONE - 1 )) )"
					;;
				roman)	count="$(swarm.str.num2roman $DONE)"
					;;
				esac

				# Add the string to array, or print array
				if [ "$CUR" -le "$MAX" ]
				then	len=0
					for O in "${OUT[@]}";do len=$[ $len + ${#O} ];done
					sum="$(( $len + 2  + ( ${#BORDER_LEFT} * 2 ) ))"

					if [ "$sum" -lt "$COLUMNS" ]
					then	OUT["$CUR"]="${count}${SEP}${OPT}"
						shown=false
						CUR="$(( $CUR + 1 ))"
					else	printe  "${OUT[@]}" >&2
						CUR=0 && unset OUT[@]
						[ -z "$OPT" ] && shown=true
						OUT["$CUR"]="${count}${SEP}${OPT}"
						CUR="$(( $CUR + 1 ))"
					fi
				else 	printe  "${OUT[@]}" >&2
					CUR=0 && unset OUT[@]
					[ -z "$OPT" ] && shown=true
					OUT["$CUR"]="${count}${SEP}$OPT"
					CUR="$(( $CUR + 1 ))"
				fi
				$as_menu && DONE="$(( $DONE + 1))"
			done
		#
		# Display
		#
			! $shown && printe  "${OUT[@]}" >&2
			return 0
	}
	pick() { # [-1 -2 -a -m] $LIST or ${ARRAYS[@]}
	# Select an item of a LIST or an ARRAY, that will be returned
	# Use -a for autoselect if only 1 entry, and -m as this will present 'Back' (translated)
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#
		# Variables
		#
			local counter=0
			local AUTO=false
			local ROWS="3"
			local as_menu=false
		#
		# Catch arguments
		#
			for opt in "${@}"
			do	if [[ "-" == "${opt:0:1}" ]]
				then	case "${opt/-}" in
					1|2|3)	ROWS="${opt/-}"
						shift
						;;
					"a")	AUTO=true
						shift
						;;
					"m")	trap "return 130" INT ABRT KILL
						as_menu=true
						shift
						;;
					esac
				fi
			done
			# Can not be set earlier because of possible options
			# Which state wether it is 'as menu' or default
			$as_menu && \
				local ARGS=( "${SWARM_MSG_PICK_BACK}" "${@}" ) || \
				local ARGS=("${@}")
		# Handle auto-pick (only 1 option)
			"$AUTO" && \
				[ "$#" -eq 1 ] && \
				$PRINTF '%s\n' "$ARGS" >&1 && \
				return 4
		# Show the items to pick from
			$as_menu && \
				printlist -n -$ROWS -0 "${ARGS[@]}" || \
				printlist -n -$ROWS "${ARGS[@]}"
		# Set dynamic values
			# Amount of arguments
			local pick_count=${#ARGS[@]}
			# Character length of the amount
			local pick_len=${#pick_count}
			# Special handling
			local invalid=true
			local todo=false
			local NUM=""
			local POS="$(swarm.print.goto $(( $identRight + 1 ))) ${SWARM_THEME_DATA[read]}"
			$as_menu && \
				local min=0 || \
				local min=1
		#
		# Visuals
		#
		while $invalid
		do
		# Print the input line:
			swarm.print.border >&2
			$PRINTF "$POS      $POS " >&2
		# Read the input
			builtin read -n $pick_len NUM
		# Catch invalid inputs
			# Keep reading if NUM is empty
			[[ -z "$NUM" ]] && continue
			# Check for arrow keys, and make sure NUM is numeric only : Thank you MIG
			[[ $NUM =~ ^[0-9]+$ ]] || continue
			# If it's exactly 0, it's BACK
			[[ ${NUM} -lt $pick_len ]] && todo=false #$PRINTF "\n" && $PRINTF "${ARGS[$NUM]}" >&1 && return 4
			# Keep reading if it is not greater than 'min'-imum
			[[ ${NUM} -ge $min ]] || continue
			# Check if the 0 index is missing
			$as_menu || NUM=$(( $NUM - 1))
			# Keep reading if it is greater than pick_count
			[[ $NUM -gt $pick_count ]] && continue
		# Exit the loop
			invalid=false
		done

		# Output
		$ECHO ${ARGS[$NUM]} >&1
		#set -x
		[[ ${#NUM} -lt ${pick_len} ]] || $PRINTF "${POS_END}\n" >&2
		#set +x
		unset opt
	}
	press() { # [-c -l -r] [STR]
	# Requires the user to press [Enter/Return] before script continues
	# c=center ,l=left , r=right
		# Vars
		local mode=""
		# Catch arguments
		for opt in "${@}"
		do	if [[ "-" == "${opt:0:1}" ]]
			then	case "${opt:1}" in
				"c")	mode="center"
					shift
					;;
				"l")	mode="left"
					shift
					;;
				"r")	mode="right"
					shift
					;;
				esac
			fi
		done
	# Display
		case "$mode" in
		"center")
			printl "" "${1:-$SWARM_MSG_PRESS_ENTER}" ""
			;;
		"left")
			printl "${1:-$SWARM_MSG_PRESS_ENTER}"
			;;
		"right")
			printl "" "" "${1:-$SWARM_MSG_PRESS_ENTER}"
			;;
		*)
			printl "${1:-$SWARM_MSG_PRESS_ENTER}" "" "${1:-$SWARM_MSG_PRESS_ENTER}"
			;;
		esac
	# Action :p
		builtin read
	}
	ask() { # "A question?"
	# Reads a user's input
	# Returns the buffer
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		hideText=""
		notEmpty=false
	# Catch options
		for opt in "${@}"
		do
			case "$opt" in
			"-n")
				notEmpty=true
				shift
				;;
			"-p")
				hideText="-s"
				shift
				;;
			esac
		done
	# Define the proper string to display
		[[ -z "$1" ]] && \
			local STR="$(swarm.print.goto $(( $identRight + 1 ))) ${SWARM_THEME_DATA[read]}" || \
			local STR="$(swarm.print.goto $(( $identRight + 1 ))) $1 ${SWARM_THEME_DATA[read]}"
	# Does it need a loop?
		if $notEmpty
		then
			while [[ -z "$buffer" ]]
			do
				swarm.print.border >&2
				$PRINTF "$STR " >&2
				builtin read $hideText buffer
			done
		else
			swarm.print.border >&2
			$PRINTF "$STR " >&2
			builtin read $hideText buffer
		fi
	# Output
		$ECHO "$buffer" >&1
	}
	edit() { # [ -c ] FILE1 FILE2 FILE3 ...
	#
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		local cli_forced=false
		local EDITOR=""
	# Get options
		for opt in "${@}"
		do
			case "${opt}" in
			"-c")
				cli_forced=true
				shift
				;;
			esac
		done
	# Prepare : first use or is variable set?
		if [[ -z "$EDITOR_GUI" ]]
		then
			title "$SWARM_MSG_EDITOR_GUI"
			list_raw="$(<${SWARM_DIR_LIST}/editor_gui)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			EDITOR_GUI=$(pick -a $list)
			cfg.set "$SWARMRC" "EDITOR_GUI" "$EDITOR_GUI"
			status $? "$SWARMRC" "EDITOR_GUI=$EDITOR_GUI"
		fi
		if [[ -z "$EDITOR_CLI" ]]
		then
			title "$SWARM_MSG_EDITOR_CLI"
			list_raw="$(<${SWARM_DIR_LIST}/editor_cli)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			EDITOR_CLI=$(pick -a $list)
			cfg.set "$SWARMRC" "EDITOR_CLI" "$EDITOR_CLI"
			status $? "$SWARMRC" "EDITOR_CLI=$EDITOR_CLI"
		fi

	# Prepare : Get the proper editor
		if ! $isGUI || $cli_forced
		then	# Its console, or forced
			[[ -n "$EDITOR_CLI" ]] && EDITOR="$EDITOR_CLI"
		else	# it is GUI
			[[ -n "$EDITOR_GUI" ]] && EDITOR="$EDITOR_GUI"
		fi
	# Action
		for F in "${@}"
		do
			$EDITOR "$F"
		done
	}
	filemgr() { # [ -c ] FILE1 FILE2 FILE3 ...
	#
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		local cli_forced=false
		local FILEMGR=""
	# Get options
		for opt in "${@}"
		do
			case "${opt}" in
			"-c")
				cli_forced=true
				shift
				;;
			esac
		done
	# Prepare : first use or is variable set?
		if [[ -z "$FILEMGR_GUI" ]]
		then
			title "$SWARM_MSG_FILEMGR_GUI"
			list_raw="$(<${SWARM_DIR_LIST}/filemgr_gui)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			FILEMGR_GUI=$(pick -a $list)
			cfg.set "$SWARMRC" "FILEMGR_GUI" "$FILEMGR_GUI"
			status $? "$SWARMRC" "FILEMGR_GUI=$FILEMGR_GUI"
		fi
		if [[ -z "$FILEMGR_CLI" ]]
		then
			title "$SWARM_MSG_FILEMGR_CLI"
			list_raw="$(<${SWARM_DIR_LIST}/filemgr_cli)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			FILEMGR_CLI=$(pick -a $list)
			cfg.set "$SWARMRC" "FILEMGR_CLI" "$FILEMGR_CLI"
			status $? "$SWARMRC" "FILEMGR_CLI=$FILEMGR_CLI"
		fi

	# Prepare : Get the proper editor
		if ! $isGUI || $cli_forced
		then	# Its console, or forced
			[[ -n "$FILEMGR_CLI" ]] && FILEMGR="$FILEMGR_CLI"
		else	# it is GUI
			[[ -n "$FILEMGR_GUI" ]] && FILEMGR="$FILEMGR_GUI"
		fi
	# Action
		# Sadly not all GUI filemanagers support tabs
		for F in "${@}"
		do
			$FILEMGR "$F"
		done
	}
	web() { # [ -c ] FILE1 FILE2 FILE3 ...
	#
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		local cli_forced=false
		local FILEMGR=""
	# Get options
		for opt in "${@}"
		do
			case "${opt}" in
			"-c")
				cli_forced=true
				shift
				;;
			esac
		done
	# Prepare : first use or is variable set?
		if [[ -z "$WEB_GUI" ]]
		then
			title "$SWARM_MSG_WEB_GUI"
			list_raw="$(<${SWARM_DIR_LIST}/web_gui)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			WEB_GUI=$(pick -a $list)
			cfg.set "$SWARMRC" "WEB_GUI" "$WEB_GUI"
			status $? "$SWARMRC" "WEB_GUI=$WEB_GUI"
		fi
		if [[ -z "$WEB_CLI" ]]
		then
			title "$SWARM_MSG_WEB_CLI"
			list_raw="$(<${SWARM_DIR_LIST}/web_cli)"
			list=""
			list=$(for l in $list_raw;do $WHICH $l 2>/dev/null ; done)
			WEB_CLI=$(pick -a $list)
			cfg.set "$SWARMRC" "WEB_CLI" "$WEB_CLI"
			status $? "$SWARMRC" "WEB_CLI=$WEB_CLI"
		fi

	# Prepare : Get the proper editor
		if ! $isGUI || $cli_forced
		then	# Its console, or forced
			[[ -n "$WEB_CLI" ]] && WEB="$WEB_CLI"
		else	# it is GUI
			[[ -n "$WEB_GUI" ]] && WEB="$WEB_GUI"
		fi
	# Action
		# Sadly not all GUI filemanagers support tabs
		for F in "${@}"
		do
			$WEB "$F"
		done
	}
	rnd() { #
	#
	#
		doPerm=false
		doList=false
		PERM_NUM=""
		LIST_NUM=""
		MIN=""
		MAX=""
		c=0
	# Catch Arguments
		case "$1" in
		"-p"|"--perm")
			doPerm=true
			PERM_NUM="$2"
			shift 2
			# Permutation requires some calulations
			case $# in
			1|2)	# If 2, too many arguments, ignoring...
				MIN=$(( $1 ))
				MAX=$(( $1 + $PERM_NUM ))
				;;
			esac
			#shift $#
			;;
		"-l"|"--list")
			doList=true
			LIST_NUM="$2"
			shift 2
			;;
		esac
		case $# in
		0)	MIN=${MIN:-1}
			MAX=${MAX:-100}
			;;
		1)	MIN=${MIN:-1}
			MAX=${MAX:-$1}
			;;
		2)	MIN=${MIN:-$1}
			MAX=${MAX:-$2}
			;;
		esac
	# Functions
		#set -x
		myRND() { #
		#
		#
			VAR=$[ $RANDOM % $MAX ]
			while  [[ $VAR -lt $MIN ]] || [[ $VAR -gt $MAX ]]
			do	VAR=$[ $RANDOM % $MAX ]
				# This is required, otherwise one never gets the 'max' value.
				VAR=$(( $VAR + 1 ))
			done
			builtin echo "$VAR"
		}
	#
	#	Display & Action
	#
	#
		if $doList
		then	declare -A L
			while [[ $c -lt $LIST_NUM ]]
			do
				n=$(myRND)
				while echo "${L[@]}" | $GREP -q $n
				do	n=$(myRND)
				done
				L[$c]=$n
				((c++))
			done
			echo "${L[@]}"
			unset L
		elif $doPerm
		then 	# This part (permutation) is originaly from RupertPumpkin
			# http://forums.fedoraforum.org/showpost.php?p=1748816&postcount=6
			# but has been modified by sea to match this command functionality
			declare -A P
			R=$RANDOM
			for x in $(eval builtin echo {${MIN}..${MAX}})
			do
				while 	[[ -n "${P[$R]}" ]]
				do	R=$RANDOM
				done
				P[$R]="$x"
			done
			echo "${P[@]}"
			unset P
		else	myRND
		fi
		#set +x
	}
