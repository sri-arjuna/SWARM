#!/usr/bin/env bash
#
# Prepare functions
# to display functions to End User (hence: eu) :P
# Please see: ./docs/{MANUAL,SYNTAX}.md) for further information
#
	swarm.eu.function.list() { # [FILE]
	# Prints a list of properly declared functions
	# see ./docs/{MANUAL,SYNTAX}.md for details
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		local tmp_oldpwd="${PWD:-$($PWD_EXEC)}"
		local tmp_file="${1##*/}"
		local tmp_dir=${1/$tmp_file}
		local target="${tmp_dir:-$SWARM_DIR_LIBS}/$tmp_file"

		if [[ -n "$tmp_file" ]] && [[ -f "$target" ]]
		then	# There is a specific file passed to parse
			cd "${tmp_dir:-$SWARM_DIR_LIBS}"
			$GREP "() { #" "$1"| \
				$GREP -v GREP | \
				$AWK -v FS='() ' '{print $1}' | \
				$SED s,'()',' ',g
			cd "$tmp_oldpwd"
		else	# Just parse all files in SWARM_DIR_LIBS ; default
			raw_output() {
				(
					cd "$SWARM_DIR_LIBS"
					$GREP init.*"() {" * | $GREP -v GREP
					$GREP cfg.*"() {" * | $GREP -v GREP
					# Yes, I could remove these functions here, but I'd like to keep my options
					# for a possible 'internal' section for the help menu
					$GREP swarm.*"() {" * | $GREP -v GREP | $GREP -v '.os.' #| $GREP -v sanity | $GREP -v '\.eu\.'
					cd "$tmp_oldpwd"
				) | while IFS=": " read _ funcname _
				do
					# The IFS takes care of the GREP filenames
					# and this variable-regex takes care of the 'function definition'
					$PRINTF '%s\n' "${funcname/()}"
				done
			}
			# Show data
			raw_output | sort -u
			unset -f raw_output
		fi
	}
	swarm.eu.function.show() { # MODE [FILE] FUNCTIONNAME		## MODE= --text || --code
	# Prints either these 2 comment lines or the code
	# Please see: ./docs/{MANUAL,SYNTAX}.md)
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#
		# Vars
		#
			local tmp_oldpwd="${PWD:-$($PWD_EXEC)}"
			local GREP_OPTS=""
		#
		# Check for args
		#
			local MODE=none
			case "$1" in
				"--text")
					MODE=text
					shift
					;;
				"--code")
					MODE=code
					shift
					;;
				*)
					MODE=text
					#return 1
					;;
			esac
			[[ -f "$1" ]] && \
				local curFILE="$1" && shift || \
				local curFILE=""
		#
		# Code
		#
			# Prepare command
			case "$MODE" in
				"text")
					GREP_OPTS="-h -a2  ${1}"
					cd "$SWARM_DIR_LIBS"
					# This is just to reduce unrequired disk usage
					[[ -n "$curFILE" ]] && \
						$GREP $GREP_OPTS "$curFILE"|| \
						$GREP $GREP_OPTS *
					cd "$tmp_oldpwd"
					;;
				"code")
					type "$1"
					;;
			esac
	}
	swarm.eu.show.submenu() { # FUNCNAME
	# Lets the user select what kind of information he wants to read
	# This is a subfunction of swarm.eu.show.basics
		printe "$SWARM_MSG_HELPMENU_BASIC_SUBMENU_TEXT"
		# Get something to work with
		# This is required to support other languages
		local item=$(pick -m "$SWARM_MSG_WORD_USAGE" "$SWARM_MSG_WORD_MANPAGE")
		# Act accordingly
		case "$item" in
		"$SWARM_MSG_WORD_USAGE")
			swarm.help.usage "$1" | printe --
			;;
		"$SWARM_MSG_WORD_MANPAGE")
			swarm.help.manpage "$1"
			;;
		esac
		return $RET_BACK
	}
	swarm.eu.show.basics() { #
	# Shows the basic core functions
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		local list="$(swarm.eu.function.list ${SWARM_DIR_LIBS}/util.enduser | $GREP -ve 'swarm.' -ve 'roman' -ve 'getlist' -ve 'getspace' -ve 'myRND' | $SORT)"
		local item=""
	# Display
		while [[ ! "$item" == "$SWARM_MSG_WORD_BACK" ]]
		do
			title 	"$SWARM_MSG_HELPMENU_ROOT_TOPIC1"
			printe 	"$SWARM_MSG_HELPMENU_BASIC_TEXT"
			item=$(pick -m $list )
			# Retun if 'back' is selected
			[[ "${item/ /}" == "${SWARM_MSG_WORD_BACK}" ]] && break #return 4
			# Action !
			title	"$item"
			swarm.eu.show.submenu "$item"
			status $? "$item"
		done
		status $RET_BACK "$SWARM_MSG_HELPMENU_ROOT_TOPIC1"
	}
	swarm.eu.show.variables() { #
	# Shows the basic core functions
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		local list="isDir isRoot isGUI DESKTOP DISTRO BASED TAR EX CP MV"
		local item=""
	# Display
		while true
		do
			title 	"$SWARM_MSG_HELPMENU_ROOT_TOPIC2"
			printe	"$SWARM_MSG_HELPMENU_VARS_TEXT"
			item=$(pick -m $list )
			case "$item" in
			"$SWARM_MSG_WORD_BACK")
				$PRINTF "$POS_END\n" >&2
				return 4
				;;
			*)
				title "$item"
				status 111 "$item=${!item}" "$(swarm.help.usage ${item})"
				press
				;;
			esac
		done
	}
	swarm.eu.show.advanced() { #
	# Shows the basic core functions
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
	# Variables
		# Get full list of all functions
		local list=$( swarm.eu.function.list | $GREP -ve "swarm.eu." -ve "swarm.sanity." -ve "init." -ve "swarm.theme." -ve "swarm.update." -ve "swarm.lang." -ve "swarm.help" -ve "swarm.cleanup" -ve "swarm.error" -ve "swarm.protect" -ve ".util." -ve ".print."  | $SORT)
		local item=""
	# Display
		while true
		do
			#clear
			#header --default "${SWARM_MSG_HELPMENU_ROOT_TITLE}"
			title 	"$SWARM_MSG_HELPMENU_ROOT_TOPIC3"
			printe	"$SWARM_MSG_HELPMENU_ADVANCED_TEXT"
			item=$(pick -m $list )
			case "$item" in
			"$SWARM_MSG_WORD_BACK")
				$PRINTF "$POS_END\n" >&2
				return 4
				;;
			*)
				swarm.eu.show.submenu "$item"
				#printe "$item" "${!item}" "$(swarm.help.usage ${!item})"
				#press
				;;
			esac
		done
	}
	swarm.eu.demo() { #
	# This simply shows some example usages
	#
		local str_title="Demo Screen"
		local C=0 M=5

		header --default "$str_title"
		title "$str_title"

		printe "Left string" "Totaly in the center" "Right string"
		if $isGUI
		then	status $RET_DONE "$SWARM_MSG_WORD_SUCCESS : \$isGUI = $isGUI" # || \
		else	status $RET_FAIL "$SWARM_MSG_WORD_FAILURE : \$isGUI = $isGUI"
		fi

		title
		printe "Contents of: /"
		printlist -r $($LS /)

		title
		yesno "Do you like using: \"$DESKTOP\" on \"$DISTRO\"?" >&1
		status $? "Your answer was: $(swarm.str.bool2str -y $?)"

		local tmp=$(pick $(swarm.theme.list))
		status $RET_SKIP "$SWARM_MSG_WORD_SELECTED : $tmp"

		title

		while [[ $C -le $M ]]
		do
			bar -b -l -m $M -c $C "my Message"
			C=$(( $C + 1 ))
			sleep 0.3
		done
		$PRINTF "${POS_END}\n"
		C=0

		while [[ $C -le $M ]]
		do
			bar -B num -m $M -c $C "my Message"
			C=$(( $C + 1 ))
			sleep 0.3
		done
		$PRINTF "${POS_END}\n"
		C=0

		while [[ $C -le $M ]]
		do
			bar -B dash "my Message"
			C=$(( $C + 1 ))
			sleep 0.3
		done
		$PRINTF "${POS_END}\n"
		C=0

		title "Copy"
		#swarm.util.cp
		$CP -v $0 /tmp
		title "Show source of itself"

		type $FUNCNAME
	}
	swarm.eu.help.menu() { # [ITEM]
	# Prints help to ITEM and returns with 1
	# Prints help menu if no ITEM is passed and returns with 0
		local item=""
	# Catch Argument
		if [[ -n "$1" ]]
		then
			case "$1" in
			"list")
				for f in $(swarm.eu.function.list| $GREP -ve "swarm.eu." -ve "swarm.sanity." -ve "init." -ve "swarm.theme." -ve "swarm.update." -ve "swarm.lang.")
				do
					swarm.help.usage "$f"
				done
				return
				;;
			*)
				swarm.help.manpage "$1"
				$PRINTF "\r"
				return $?
				;;
			esac
		fi
	# Display
		while true
		do
			clear
			header --default "${SWARM_MSG_HELPMENU_ROOT_TITLE}"
			title "${SWARM_MSG_HELPMENU_ROOT_TITLE}"
			printe "${SWARM_MSG_HELPMENU_ROOT_TEXT1}"

			local mnu_root_array=("$SWARM_MSG_HELPMENU_ROOT_TOPIC1" "$SWARM_MSG_HELPMENU_ROOT_TOPIC2" "$SWARM_MSG_HELPMENU_ROOT_TOPIC3" )
			item=$(pick -2 -m  "${mnu_root_array[@]}") #$(swarm.eu.function.list))" || item=""

			case "$item" in
			"${SWARM_MSG_WORD_BACK}")
				$PRINTF "$POS_END\n" >&2
				return 4
				;;
			"$SWARM_MSG_HELPMENU_ROOT_TOPIC1")
				# Basic functions
				swarm.eu.show.basics
				;;
			"$SWARM_MSG_HELPMENU_ROOT_TOPIC2")
				# Variables
				swarm.eu.show.variables
				;;
			"$SWARM_MSG_HELPMENU_ROOT_TOPIC3")
				# Advanced functions
				swarm.eu.show.advanced
				;;
			esac
		done
	}
	swarm.eu.new.menu() { #
	# Shows a basic menu wrapper for new stuff
	#
		header --default "$SWARM_MSG_WORD_MENU : $1"
		title "${SWARM_MSG_WORD_SELECT}: $SWARM_MSG_WORD_ACTION"
		local F="$SWARM_MSG_WORD_FUNCTION"
		local S="$SWARM_MSG_WORD_SCRIPT"
		while item=$(pick -m $F $S)
		do
			[[ "$F" == "$item" ]] && action=function
			[[ "$S" == "$item" ]] && action=script
			[[ -z "$action" ]] && break
			swarm.eu.new.$action
			item=""
			action=""
		done
		#status $?
	}
	swarm.eu.new.function() { #
	# As of now.. prints a function template
	#
		cat<<-EO_SCREEN
		funcname() { # [option] ARG
		#
		#
		 	swarm.protect "\$FUNCNAME (\${CALLER:-unkown})" "\${@}" && exit 1
		# Variables
		 	local RET=1
		# Catch arguments
		 	while :
		 	do
		 		case \$1 in
		 		-h|-\?|--help)
		 			builtin echo "\$SWARM_MSG_WORD_USAGE: \$FUNCNAME [ \${SWARM_MSG_WORD_OPTIONS,,} ] [ \${SWARM_MSG_WORD_ARGUMENTS^^} ]"
		 			return 0
		 			;;
		 		--)
		 			# General purpose pipe support, might need adjustment!
		 			while read line;do
		 				\$FUNCNAME "\$line"
		 			done
		 			return 0
		 			;;
		 		*)
		 			break
		 			;;
		 		esac
		 		shift
		 	done
		# Action & Display
		 	title "Something"
		 	printe "information"
		 	return \$RET
		}
		EO_SCREEN
	}
	swarm.eu.new.script() { # [-s -l -f] [NAME]
	# Without arguments this will show a selection menu for the available scripts
	# When NAME is passed from cli, it will create a new script in $SWARM_USER_DIR_SCRIPTS (eg: ~/bin)
		local item
		local newname
		if [[ -z "$1" ]]
		then	# No arguments, menu handling
			while :; do
				title "$SWARM_MSG_WORD_SCRIPT"
				printe "$SWARM_MSG_NEW_SCRIPT_SELECTION"
				item=$(pick -m $( cd "$SWARM_DIR_TEMPLATES/scripts/";$LS))
				[[ "$item" == "${SWARM_MSG_WORD_BACK}" ]] && break
				newname=$(ask "$SWARM_MSG_PHRASE_NEWNAME")
				#set -x
				swarm.util.cp  "$SWARM_DIR_TEMPLATES/scripts/$item" "$SWARM_USER_DIR_SCRIPTS/$newname"
				chmod +x "$SWARM_USER_DIR_SCRIPTS/$newname"
				#set +x
				#status $? "$SWARM_MSG_WORD_COPIED $SWARM_MSG_WORD_FILE: $item - $newname"
				return $?
			done
		else
			# variable prepare
			tmp_name="${2:-${1:-$(swarm.str.genfilename newscript.sh)}}"
			case $1 in
			-l)
				swarm.util.cp  "$SWARM_DIR_TEMPLATES/scripts/lib" "$SWARM_USER_DIR_SCRIPTS/${tmp_name}"
				;;
			-s)
				swarm.util.cp  "$SWARM_DIR_TEMPLATES/scripts/small" "$SWARM_USER_DIR_SCRIPTS/${tmp_name}"
				;;
			-f|*)
				swarm.util.cp  "$SWARM_DIR_TEMPLATES/scripts/full" "$SWARM_USER_DIR_SCRIPTS/${tmp_name}"
				;;
			#*)
			#	break
			#	;;
			esac
			chmod +x "$SWARM_USER_DIR_SCRIPTS/$newname"
			exit $?
		fi
	}
