#!/usr/bin/env bash
#
# Prepare functions
# that are supposed to be used by 'enduser' script authors
# Stuff like: yeno, pick, printe, header, title and 'all the rest'
#
#
# Visual outputs - 'End user' stuff
#
	header() { # LEFT CENTER RIGHT
	# This prints a full line in blue (default-back), with white (default-front) text
	# TODO long string adjustments TODO, uses script_{name,version} before it uses its SWARM counterparts
		case "$1" in
		"--")
			shift
			while $READ -r line;do
				# shellcheck disable=SC2154
				header "" "$line" ""
			done
			return 0
			;;
		"--default")
			shift
			# shellcheck disable=SC2068
			swarm.print.text -h \
				"${script_name:-SWARM} ${script_version:-${SWARM[VERSION]}-${SWARM[BUILD]}} ($(swarm.sysinfo.os.distro|$SED s,'"','',g))" \
				"" \
				"$($PRINTF '%s ' ${@}) | $($DATE_TODAY) / $($DATE_TIME)"
			;;
		esac
	# Action
		swarm.print.border -h
		local len=$(( COLUMNS - lenRight - lenLeft - 2   ))
		case "${#@}" in
		2)	if [[ $(( ${#1} + ${#2} )) -gt $len ]]
			then	# needs splitting
				local l1 l2 r1 r2
				SPLIT1="" SPLIT2=""

				if [[ ${#1} -gt $len ]]
				then	# Left needs split
					swarm.str.split "$1" >/dev/zero
					l1="$SPLIT1"
					l2="$SPLIT2"
					swarm.print.text -h "$l1"
					swarm.print.text -h "$l2" "" "$2"
				elif [[ ${#2} -gt $len ]]
				then	# right nees splitting
					swarm.str.split "$2" >/dev/zero
					r1="$SPLIT1"
					r2="$SPLIT2"
					swarm.print.text -h "$1" "" "$r1"
					swarm.print.text -h "" "" "$r2"
				else
					swarm.print.text -h "$1" "" ""
					swarm.print.text -h "" "" "$2"
				fi
			else	swarm.print.text -h "$1" "" "$2"
			fi
			;;
		*)	if [[ $(( ${#1} + ${#2} + ${#3} )) -gt $len ]]
			then	local l1 l2 m1 m2 r1 r2
				SPLIT1="" SPLIT2=""
				if [[ ${#1} -gt $len ]]
				then	# Left needs split
					swarm.str.split "$1" >/dev/zero
					l1="$SPLIT1"
					l2="$SPLIT2"
					swarm.print.text -h "$l1" "" ""
					swarm.print.text -h "$l2" "$2" "$3"
				elif [[ ${#2} -gt $len ]]
				then	# right nees splitting
					swarm.str.split "$2" >/dev/zero
					m1="$SPLIT1"
					m2="$SPLIT2"
					swarm.print.text -h "$1" "$m1" ""
					swarm.print.text -h "" "$m2" "$3"
				elif [[ ${#3} -gt $len ]]
				then	# right nees splitting
					swarm.str.split "$3" >/dev/zero
					r1="$SPLIT1"
					r2="$SPLIT2"
					swarm.print.text -h "$1" "" "$r1"
					swarm.print.text -h "" "$2" "$r2"
				else
					swarm.print.text -h "$1" "" "$3"
					swarm.print.text -h "" "$2" ""
				fi
			else	swarm.print.text -h "$1" "$2" "$3"
			fi
			;;
		esac
	}
	title() { # Text
	# This prints a single centered string on a line
	# It has blue borders and fills the inner line with white (Default-{front,back})
		if [[ "--" == "$1" ]]
		then
			while $READ -r line;do
				title "$line"
			done
			return 0
		else
			swarm.print.border -t
			if [[ $(( ${#1} + lenRight + lenLeft )) -gt $(( COLUMNS - 2 )) ]]
			then	# Needs splitting
				swarm.str.split "$1" >/dev/zero
				swarm.print.text -n -t "${SPLIT1}"
				swarm.print.border -t
				swarm.print.text -n -t "${SPLIT2}"
			else	#
				swarm.print.text -n -t "${1}"
			fi
		fi
	}
	printe() { # [-|--] STR1 STR2 STR3
	# Simply prints the strings as passed, it requires 3 strings to use the center
	# For piping, it expects 3 lines, each representing 1 variable
		local MODE="none" doCenter=false
		local localOpts="" ORIENTATION="default"
		local doNewline=false
		lenBorder=$(( lenLeft + lenRight + 2 ))
	# Get args
		while :;do
			case "$1" in
			"-1"|"-2"|"-3")
				MODE="${1/-}"
				localOpts+=" $1"
				;;
			"--left")
				ORIENTATION="left"
				localOpts+=" $1"
				#doNewline=false
				;;
			"--center")
				ORIENTATION="center"
				localOpts+=" $1"
				#doNewline=false
				;;
			"--right")
				ORIENTATION="right"
				localOpts+=" $1"
				#doNewline=false
				;;
			"-n")
				doNewline=true
				;;
			"-"|"--")
				shift
				case $MODE in
				1)
					while $READ -r line
					do	printe $localOpts "$line"
					done
					return 0
					;;
				2)
					while $READ -r line
					do	$READ -r line2
						printe $localOpts "$line" "$line2"
					done
					return 0
					;;
				3|*)
					while $READ -r line
					do	$READ -r line2
						$READ -r line3
						printe $localOpts "$line" "$line2" "$line3"
					done
					return 0
					;;
				esac
				;;
			*)	break
				;;
			esac
			shift
		done
	# Get arg number if not forced yet
		[[ "normal" == "$MODE" ]] && [[ "-" != "$1" ]] && [[ "--" != "$1" ]] && MODE=${#@}
	# Get the actual string
		local ARGS=("${@}")
		local L="${ARGS[0]}"
		local M="${ARGS[1]}"
		local R="${ARGS[2]}"
		case ${#@} in
		2)	# Its two arguments, so 2nd must go right
			R="$M"
			M=""
			;;
		esac
	# Now handle input
		local breaker=0
		# This produces kind of a hash-value to directly jump to the required task.
		[[ -n "$L" ]] && ((breaker++))
		[[ -n "$M" ]] && ((breaker+=4))
		[[ -n "$R" ]] && ((breaker+=8))
	# Make it super simple
		swarm.print.border
		case "$breaker" in
		1)	# Left oriented
			local l_is_greater=false
			# Lets handle variable splitting here - if need be
			if [[ ${#L} -gt $((COLUMNS - lenBorder)) ]]
			then	l_is_greater=true
				SPLIT1="" SPLIT2=""
				swarm.str.split "$L" >/dev/zero
				L_one="$SPLIT1"
				L_two="$SPLIT2"
			fi
		# Get the LEFT action
			case "$ORIENTATION" in
			default) # Default is left anyway, so using that
				if $l_is_greater
				then	# L is wider than the terminal
					swarm.print.text -n "$L_one"
					swarm.print.border
					swarm.print.text -n "$L_two"
					return
				else	swarm.print.text -n "$L"
				return
				fi
				;;
			left)
				# Default behaviour for 1 argument on the left
				if $l_is_greater
				then	# L is wider than the terminal
					swarm.print.text -n "$L_one"
					swarm.print.border
					swarm.print.text -n "$L_two"
					return
				else	swarm.print.text "$L"
				return
				fi
				;;
			center) # Special handle for orientation
				if $l_is_greater
				then	# L is wider than the terminal
					swarm.print.text -n "" "$L_one" ""
					#[[ "x$MODE" == "xtitle" ]] && $PRINTF "\n" >&1		## TODO : not sure.....
					swarm.print.border
					swarm.print.text -n "" "$L_two" ""
					return
					#$doStart || return 0
				else	swarm.print.text  "" "$L" ""
				#$doNewline || return
				fi
				;;
			right) # Special handle for orientation
				if $l_is_greater
				then	# L is wider than the terminal
					swarm.print.text -n "" "" "$L_one"
					#$PRINTF "\n"  >&1
					swarm.print.border
					swarm.print.text -n  "" "" "$L_two"
					return
				else	swarm.print.text  "" "" "$L"
				return
				fi
				;;
			esac
			;;
		4)	#   Middle / Center oriented
			swarm.print.text -n "" "$M" ""
			return
			;;
		8)	#     R
			swarm.print.text -n "" "" "$R"
			return
			;;
		# -----------------------
		5)	# L M
		# L
			local l_is_greater=false
			# Lets handle variable splitting here - if need be
			if [[ ${#L} -gt $((COLUMNS - lenBorder)) ]]
			then	l_is_greater=true
				SPLIT1="" SPLIT2=""
				swarm.str.split "$L" >/dev/zero
				L_one="$SPLIT1"
				L_two="$SPLIT2"
			fi
		# M	# Handle the both:
			if $l_is_greater
			then	swarm.print.text -n "$L_one" "" ""
				swarm.print.border
				swarm.print.text -n "$L_two" "$M" ""
				return
			else	# only here we need to handle the R argument
				local r_is_greater=false
				# Lets handle variable splitting here - if need be
				if [[ ${#M} -gt $((COLUMNS - lenBorder)) ]]
				then	SPLIT1="" SPLIT2=""
					swarm.str.split "$M" >/dev/zero
					swarm.print.text -n "$L" "$SPLIT1" ""
					swarm.print.border
					swarm.print.text -n "" "$SPLIT2" ""
					return
				else	# Neither L nor R needs splitting
					# However, can they be printed on the same line?
					if [[ $(( ${#L} + ${#R} + (2* $lenRight) )) -lt $COLUMNS  ]]
					then 	# default
						swarm.print.text -n "$L" "$M" ""
						return
					else 	# print on different lines
						swarm.print.text -n "$L" "" ""
						swarm.print.text -n "" "$M" ""
						return
					fi
				fi
			fi
			;;
		9)	# L   R
		# L
			local l_is_greater=false
			# Lets handle variable splitting here - if need be
			if [[ ${#L} -gt $((COLUMNS - lenBorder )) ]]
			then	l_is_greater=true
				SPLIT1="" SPLIT2=""
				swarm.str.split "$L" >/dev/zero
				L_one="$SPLIT1"
				L_two="$SPLIT2"
			fi
		# Handle the both:
			if $l_is_greater
			then	#echo yay
				swarm.print.text -n "$SPLIT1" "" ""
				swarm.print.border
				swarm.print.text -n "$SPLIT2" "" "$R"
				return
			else	# only here we need to handle the R argument
				local r_is_greater=false
				# Lets handle variable splitting here - if need be
				if [[ ${#R} -gt $((COLUMNS - lenBorder)) ]]
				then	SPLIT1="" SPLIT2=""
					swarm.str.split "$R" >/dev/zero
					swarm.print.text -n "$L" "" ""
					swarm.print.border
					swarm.print.text -n "" "" "$SPLIT1"
					swarm.print.border
					swarm.print.text -n "" "" "$SPLIT2"
					return
				else	# Neither L nor R needs splitting
					# However, can they be printed on the same line?
					if [[ $(( ${#L} + ${#R} + (2* $lenRight) )) -lt $COLUMNS  ]]
					then 	# default
						swarm.print.text -n "$L" "" "$R"
						return
					else 	# print on different lines
						swarm.print.text -n "$L" "" ""
						swarm.print.text -n "" "" "$R"
						return
					fi
				fi
			fi
			;;
		12)	#   M R
		# M
			local m_is_greater=false
			# Lets handle variable splitting here - if need be
			if [[ ${#M} -gt $((COLUMNS - lenBorder)) ]]
			then	m_is_greater=true
				SPLIT1="" SPLIT2=""
				swarm.str.split "$M" >/dev/zero
				M_one="$SPLIT1"
				M_two="$SPLIT2"
			fi
		# Handle the both:
			if $m_is_greater
			then	swarm.print.text -n "$M_one" "" ""
				swarm.print.border
				swarm.print.text -n "$M_two" "$R"
			else	# only here we need to handle the R argument
				local r_is_greater=false
				# Lets handle variable splitting here - if need be
				if [[ ${#R} -gt $((COLUMNS - lenBorder)) ]]
				then	SPLIT1="" SPLIT2=""
					swarm.str.split "$R" >/dev/zero
					swarm.print.text -n "" "$M" "$SPLIT1"
					swarm.print.border
					swarm.print.text -n "" "" "$SPLIT2"
					return
				else	# Neither M nor R needs splitting
					# However, can they be printed on the same line?
					if [[ $(( ${#M} + ${#R} + (2* $lenRight) + 2 )) -lt $COLUMNS  ]]
					then 	# default
						swarm.print.text -n "" "$M" "$R"
						return
					else 	# print on different lines
						swarm.print.text -n "" "$M" ""
						swarm.print.text -n "" "" "$R"
						return
					fi
				fi
			fi
			;;
		# ----------------------
		13)	# L M R
		# Just testing
			local L_one="" L_two=""
			local M_one="" M_two=""
			local R_one="" R_two=""
		# Prepare
			swarm.str.split "$L" >/dev/zero
			L_one="$SPLIT1"
			L_two="$SPLIT2"
			swarm.str.split "$M" >/dev/zero
			M_one="$SPLIT1"
			M_two="$SPLIT2"
			swarm.str.split "$R" >/dev/zero
			R_one="$SPLIT1"
			R_two="$SPLIT2"
		# Make this one simple
			swarm.print.text -n "$L_one" "$M_one" "$R_one"
			swarm.print.border
		#	swarm.print.text -n "$L_two" "$M_two" "$R_two"
			return
			;;
		esac
		${doNewline:-false} && $PRINTF "$POS_END\n"
	}
#
# Visual outputs - 'End user' stuff - Core Convenience
#
	yesno() { # "What question?"
	# Ask a yes/no question, returns 0/true for yes and 1/false for no
	# y/n are taken from language file and are used in code
		local Y="${SWARM_MSG_WORD_YES:0:1}"
		local N="${SWARM_MSG_WORD_NO:0:1}"
		local failsafe=0
		# Check if 'yesno' is empty, if so, fill with fallback values
		case "$1" in
		"--help"|"-h")
			swarm.help.usage "${FUNCNAME[@]}"
			return 99
			;;
		esac
		[[ -z "${SWARM_MSG_WORD_YES}${SWARM_MSG_WORD_NO}" ]] && \
			SWARM_MSG_WORD_YES="+" && \
			SWARM_MSG_WORD_NO="-"

		swarm.print.border
		# Print the text
		local yn="${SWARM_MSG_WORD_YES:0:1}${SWARM_MSG_WORD_NO:0:1}"
		local str1=""
		str1="$(swarm.print.goto $(( ${#SWARM_THEME_DATA[border-left]} + 2  )))$1 (${yn,,})"
		# Move the cursor
		local str2=""
		str2="$(swarm.print.goto $(( COLUMNS - ${#SWARM_THEME_DATA[border-left]} - 1  )))"
		local RET=""
		while [[ -z "$RET" ]]
		do
			$PRINTF "$str1"
			$PRINTF "$str2"
			$READ -r -n 1 answer

			case "$answer" in
			"+"|"${Y,,}")
				RET=0
				;;
			"-"|"${N,,}")
				RET=1
				;;
			esac
			((failsafe++)) ; [[ $failsafe -gt 100 ]] && return 1
		done
		# Leave line
		$PRINTF "$posEND\n"
		return "$RET"
	}
	status() { # [ -r -c] $? ["Text Left"] ["Text Center"]
	# Prints text and exit with passed return code
	#
		unset RET TXT1 TXT2
		local doReturn=false
	# Check for options
		for opt in "${@}"
		do
			case "${opt}" in
			"-r")
				doReturn=true
				shift
				;;
			"-c")
				$PRINTF "$(swarm.print.goto 0)\e[2K"
				shift
				;;
			esac
		done
	# Check for minimal arguments
		[[ -z "$1" ]] && \
			$PRINTF '%s\n' "$SWARM_MSG_STATUS_ARG_INVALID" && \
			return 99
		local RET="$1" len_allowed=15
		local value="" ; value=$(swarm.str.status "$RET")
		len_allowed=$(( COLUMNS - ${#BORDER_LEFT} - ${#BORDER_RIGHT} ))
		swarm.print.border >&3
		if [[ $(( ${#2} + ${#3} + 8 )) -gt $len_allowed ]]
		then	if [[ ${#2} -gt ${#3} ]]
			then	declare two_first two_scnd
				#echo "arbeite mit ${#2} : $2"
				$ECHO "$2" | swarm.str.split -- | \
					while $READ line
					do
						two_first="$line"
						$READ line2
						two_scnd="$line2"

					swarm.print.text -n "${two_first}" "" "" >&1
					swarm.print.border >&3
					swarm.print.text -r "$two_scnd" "${3}" "" >&1
					done
			else	declare three_first three_scnd
				#echo "arbeite mit ${#2} : $2"
				$ECHO "$3" | swarm.str.split -- | \
					while $READ line
					do
						three_first="$line"
						$READ line2
						three_scnd="$line2"

					swarm.print.text -n "" "$three_first" "" >&1
					swarm.print.border >&3
					swarm.print.text -r "$2" "${three_scnd}" "" >&1
					done
			fi
		else	# DINGELINGELING.. Aaaand eeeeverything is good!
			swarm.print.text  "$2" "$3" "" >&1
		fi

		# Adjust fixer according to X or TTY, used to be required by TUI
		#[[ -n "${XDG_CURRENT_DESKTOP:-${DESKTOP_SESSION:-$XAUTHORITY}}" ]] && \
		#	gui_fixer="7" || \
			gui_fixer=7

		$PRINTF "$(swarm.print.goto $(( ${COLUMNS:-$(${TPUT:-\tput} cols)} - ${#SWARM_THEME_DATA[border-left]} - 1 - gui_fixer  )))"  # Sehe keinen unterschied zw. 4 bis 7
		#$PRINTF "$(swarm.print.goto $(( $COLUMNS / 2 * 2 - ${#SWARM_THEME_DATA[border-left]} - 2 - $gui_fixer  )))"  # Sehe keinen unterschied zw. 4 bis 7
		$PRINTF "$value" >&1

		# shellcheck disable=SC2015
		$doReturn && \
			$PRINTF "$(swarm.print.goto 0)" || \
			$PRINTF "$posEND\n"
		return "$RET"
	}
	printlist() { # [options] $LIST or ${ARRAYS[@]}
	# Prints up to 3 'indexed'/numbered entries per row
	# Options -12arn ; 1 or 2 rows (instead of 3=default), alpha, roman, num=default
		#
		# Variable defaults (options)
		#
			local MODE=none
			local SEP=""
			local ROWS=3
			local as_menu=false
		#
		# Catch arguments
		#
			for opt in "${@}"
			do 	# Only parse for Arguments
				# if variable:'opt' starts with '-'
				[[ "-" == "${opt:0:1}" ]] && \
					case "${opt/-}" in
					"1" | "2" | "3")
						ROWS="${opt/-}"
						shift
						;;
					"0")	as_menu=true
						shift
						;;
					"a")	MODE=alpha
						SEP=") "
						shift
						;;
					"r")	MODE=roman
						SEP=". "
						shift
						;;
					"n")	MODE=num
						SEP=") "
						shift
						;;
					esac
			done
			[ -z "$1" ] && \
				while IFS= read -r ARG
				do	set -- "$@" "$ARG"
				done
			ARGS=( "${@}")
			# Update geometry
			swarm.update.geometry
		#
		# Action
		#
			# shellcheck disable=SC2184
			unset OUT[@]
			OUT[0]=""
			local shown=false
			local MAX=$(( ROWS - 1 ))
			local CUR=0
			local DONE=0
			local count=""
			for OPT in "${ARGS[@]}"
			do	$as_menu || ((DONE++))
				# Do the visible counter
				case "$MODE" in
				num)	count="$DONE"
					;;
				alpha)	count="$(swarm.str.num2char $(( DONE - 1 )) )"
					;;
				roman)	count="$(swarm.str.num2roman $DONE)"
					;;
				esac

				# Add the string to array, or print array
				if [ "$CUR" -le "$MAX" ]
				then	len=0
					for O in "${OUT[@]}";do len=$(( len + ${#O} ));done
					sum="$(( len + 2  + ( ${#BORDER_LEFT} * 2 ) ))"

					if [ "$sum" -lt "$COLUMNS" ]
					then	OUT["$CUR"]="${count}${SEP}${OPT}"
						shown=false
						((CUR++))
					else	printe  "${OUT[@]}" >&1
						# shellcheck disable=SC2184
						CUR=0 && unset OUT[@]
						[ -z "$OPT" ] && shown=true
						OUT["$CUR"]="${count}${SEP}${OPT}"
						((CUR++))
					fi
				else 	printe  "${OUT[@]}" >&1
					# shellcheck disable=SC2184
					CUR=0 && unset OUT[@]
					[ -z "$OPT" ] && shown=true
					OUT["$CUR"]="${count}${SEP}$OPT"
					((CUR++))
				fi
				$as_menu && ((DONE++))
			done
		#
		# Display
		#
			! $shown && printe  "${OUT[@]}" >&1
			return 0
	}
	pick() { # [-1 -2 -a -m] $LIST or ${ARRAYS[@]}
	# Select an item of a LIST or an ARRAY, that will be returned
	# Use -a for autoselect if only 1 entry, and -m as this will present 'Back' (translated)
	#
	# Variables
	#
		local AUTO=false failsafe=0
		local ROWS=""
		ROWS="3"
		local as_menu=false
	#
	# Catch arguments
	#
		for opt in "${@}"
		do	if [[ "-" == "${opt:0:1}" ]]
			then	case "${opt/-}" in
				1|2|3)	ROWS="${opt/-}"
					shift
					;;
				"a")	AUTO=true
					shift
					;;
				"m")	trap "return 130" INT ABRT
					as_menu=true
					shift
					;;
				esac
			fi
		done
		# Can not be set earlier because of possible options
		# Which state wether it is 'as menu' or default
		# shellcheck disable=SC2015
		$as_menu && \
			local ARGS=( "${SWARM_MSG_WORD_BACK}" "${@}" ) || \
			local ARGS=("${@}")
	# Handle auto-pick (only 1 option)
		$AUTO && \
			[ "$#" -eq 1 ] && \
			$PRINTF '%s\n' "${ARGS[@]}" >&1 && \
			return 4
	# Show the items to pick from
		# shellcheck disable=SC2015
		$as_menu && \
			printlist -n -"$ROWS" -0 "${ARGS[@]}" || \
			printlist -n -"$ROWS" "${ARGS[@]}"
	# Set dynamic values
		# Amount of arguments
		local pick_count=${#ARGS[@]}
		# Character length of the amount
		local pick_len=${#pick_count}
		# Special handling
		local invalid=true
		#local todo=false
		local NUM=""
		local POS=""
		# shellcheck disable=SC2154
		POS="$(swarm.print.goto $(( identRight + 2 ))) ${SWARM_THEME_DATA[read]}"
		# shellcheck disable=SC2015
		$as_menu && \
			local min=0 || \
			local min=1
	#
	# Visuals
	#
		while ${invalid:-true}
		do
			# Print the input line:
			swarm.print.border
			$PRINTF "$POS      $POS " >&3
		# Read the input
			${READ:-read} -n "$pick_len" NUM
		# Catch invalid inputs
			# Keep reading if NUM is empty
			[[ -z "$NUM" ]] && continue
			# Check for arrow keys, and make sure NUM is numeric only : Thank you MIG
			[[ $NUM =~ ^[0-9]+$ ]] || continue
			# If it's exactly 0, it's BACK
			#[[ ${NUM} -lt $pick_len ]] && todo=false #$PRINTF "\n" && $PRINTF "${ARGS[$NUM]}" >&1 && return 4
			# Keep reading if it is not greater than 'min'-imum
			[[ ${NUM} -ge $min ]] || continue
			# Check if the 0 index is missing
			$as_menu || ((NUM--))
			# Keep reading if it is greater than pick_count
			[[ $NUM -gt $pick_count ]] && continue
		# Exit the loop
			invalid=false
			((failsafe++)) ; [[ $failsafe -gt 100 ]] && return 1
		done

	# Output
		PICKED="${ARGS[$NUM]}"
		#$ECHO "$PICKED" >&1
		$as_menu && \
			REPLY=$NUM || \
			REPLY=$(( NUM +1 ))
		[[ ${#NUM} -lt ${pick_len} ]] || $PRINTF "${POS_END}\n" >&3
		unset opt
	}
	press() { # [-c -l -r] [STR]
	# Requires the user to press [Enter/Return] before script continues
	# c=center ,l=left , r=right
	# Vars
		local mode=""
		local doReturn=false
	# Catch arguments
		for opt in "${@}"
		do	if [[ "-" == "${opt:0:1}" ]]
			then	case "${opt:1}" in
				"c")	mode="center"
					shift
					;;
				"l")	mode="left"
					shift
					;;
				"r")	mode="right"
					shift
					;;
				#"R")	doReturn=true
				#	shift
				#	;;
				esac
			fi
		done
	# Display
		swarm.print.border >&3
		case "$mode" in
		"center")
			swarm.print.text --center "${1:-$SWARM_MSG_PRESS_ENTER}"
			;;
		"left")
			swarm.print.text "${1:-$SWARM_MSG_PRESS_ENTER}"
			;;
		"right")
			swarm.print.text "" "" "${1:-$SWARM_MSG_PRESS_ENTER}"
			;;
		*)	# Default / fallback mode
			swarm.print.text "${1:-$SWARM_MSG_PRESS_ENTER}" "" "${1:-$SWARM_MSG_PRESS_ENTER}"
			;;
		esac
	# Action :p
		#$doReturn && \
		#	$PRINTF "$(swarm.print.goto 0)" && \
		#	(var=$(builtin read -u buffer n0 2>/dev/null)) & || \
			$READ -r
	}
	ask() { # "A question?"
	# Reads a user's input
	# Returns the buffer
	# Variables
		local hideText="" buffer="" STR=""
		local notEmpty=false failsafe=0
	# Catch options
		for opt in "${@}"
		do
			case "$opt" in
			"-n")
				notEmpty=true
				shift
				;;
			"-p")
				hideText="-s"
				shift
				;;
			esac
		done
	# Define the proper string to display
		[[ -z "$1" ]] && \
			STR="$(swarm.print.goto $(( identRight + 1 ))) ${SWARM_THEME_DATA[read]}" || \
		 	STR="$(swarm.print.goto $(( identRight + 1 ))) $1 ${SWARM_THEME_DATA[read]}"
	# Does it need a loop?
		if $notEmpty
		then
			while [[ -z "$buffer" ]]
			do
				((failsafe++)) ; [[ $failsafe -gt 100 ]] && return 1
				swarm.print.border >&3
				$PRINTF "$STR " >&1
				$READ $hideText buffer
			done
		else
			swarm.print.border >&3
			$PRINTF "$STR " >&1
			$READ $hideText buffer
		fi
	# Output
		swarm.protect "$FUNCNAME" "$buffer" && return 1
		$ECHO "$buffer" >&1
	}
	rnd() { #
	#
	#
		doPerm=false
		doList=false
		PERM_NUM=""
		LIST_NUM=""
		MIN=""
		MAX=""
		c=0
	# Catch Arguments
		case "$1" in
		"-p"|"--perm")
			doPerm=true
			PERM_NUM="$2"
			# Permutation requires some calulations
			case $# in
			1|2)	# If 2, too many arguments, ignoring...
				MIN=$(( $1 ))
				MAX=$(( $1 + PERM_NUM ))
				;;
			esac
			shift 2
			;;
		"-l"|"--list")
			doList=true
			LIST_NUM="$2"
			shift 2
			;;
		esac
		case $# in
		0)	MIN=${MIN:-1}
			MAX=${MAX:-100}
			;;
		1)	MIN=${MIN:-1}
			MAX=${MAX:-$1}
			;;
		2)	MIN=${MIN:-$1}
			MAX=${MAX:-$2}
			;;
		esac
	# Functions
		_myRND() { #
		#
		#
			VAR=$(( RANDOM % MAX ))
			while  [[ $VAR -lt $MIN ]] || [[ $VAR -gt $MAX ]]
			do	VAR=$(( RANDOM % MAX ))
				# This is required, otherwise one never gets the 'max' value.
				((VAR++))
			done
			$ECHO "$VAR"
		}
	#
	#	Display & Action
	#
		if $doList
		then	declare -A L
			while [[ $c -lt $LIST_NUM ]]
			do
				n=$(_myRND)
				while $ECHO "${L[@]}" | $GREP -q "$n"
				do	n=$(_myRND)
				done
				L[$c]=$n
				((c++))
			done
			$ECHO "${L[@]}"
			unset L
		elif $doPerm
		then 	# This part (permutation) is originaly from RupertPumpkin
			# http://forums.fedoraforum.org/showpost.php?p=1748816&postcount=6
			# but has been modified by sea to match this command functionality
			declare -A P
			R=$RANDOM
			for x in $(eval "$ECHO" "{${MIN}..${MAX}}")
			do
				while 	[[ -n "${P[$R]}" ]]
				do	R=$RANDOM
				done
				P[$R]="$x"
			done
			$ECHO "${P[@]}"
			unset P
		else	_myRND
		fi
	}
	wait() { # NUM{s,m,h} [MSG]
	# Counts down from passed NUM, if neither 'm' nor 'h' is passed, it assumes seconds.
	#
		local beVerbose=false
	# Catch options
		for opt in "${@}"
		do
			case "${opt}" in
			"-v")
				beVerbose=true
				shift
				;;
			esac
		done

		TIME="${1/[a-zA-Z]}"
		UNIT=$($ECHO "${1}"|$TR -d [[:digit:]])
		[[ -z "$UNIT" ]] && UNIT="s"

		#set -x
		if [[ "$1" == "$TIME$UNIT" ]]
		then	# all Good
			$ECHO>/dev/null
		else
			$ECHO "$SWARM_MSG_WAIT_USAGE"
			return 1
		fi
		if [[ -z "$UNIT" ]]
		then	if [[ -z "$TIME" ]]
			then
				$ECHO "$SWARM_MSG_WAIT_USAGE"
				return 1
			fi
			if ! $ECHO "${UNIT:-s}"|${GREP:-grep} -v ^[smh]
			then
				$ECHO "$SWARM_MSG_WAIT_FAIL"
				return 1
			fi
		fi
		#set +x

		[[ -z "$2" ]] && \
			MSG="$SWARM_MSG_WAIT_TIME_LEFT" || \
			MSG="$2"

		case "${UNIT,,}" in
		s)	seconds_total="$TIME"	;;
		m)	seconds_total="$(( 60 * TIME ))"	;;
		h)	seconds_total="$(( 60 * 60 * TIME ))"	;;
		*)	status 1 "$SWARM_MSG_WAIT_USAGE"
			return $?
			;;
		esac
	#
	#	Action - loop
	#
		seconds_total="${seconds_total//\/}"
		while [[ $seconds_total -ge 0 ]]
		do 	# Get total TIME string and subtract 1 second
			TIME_string=$(swarm.str.seconds2time "$seconds_total")
			if [[ $seconds_total -ne 0 ]]
			then	((seconds_total--))
				# Display to user
				swarm.print.border -c
				swarm.print.text "${2:-$MSG}" " " "$(swarm.str.seconds2time "$seconds_total")"
				# Wait -- Lets give the system time to 'update' itself...
				sleep 0.999
			else
				# Verbose / Countdown?
				if ${beVerbose}
				then	[[ $seconds_total -lt 0 ]] ||\
						{ $PRINTF "\n" ; break ; }
				fi
				break
			fi
		done
		$PRINTF "\n"
		return 0
	}
	printfile() { # FILE | --
	# Prints all given files line by line, separated by "title 'filename'"
	# -- or no arguments will use read
		local tmpline="" tmplineb=""
		for file in "${@}"
		do
			if [[ -f "$file" ]]
			then	title "$file"
				while $READ -r line;do
					tmpline="${line/\|/${PRINTABLE_PIPECHAR}}"
					tmplineb="${tmpline/\>/${PRINTABLE_GREATER}}"
					printe "${tmplineb/\</${PRINTABLE_LESSER}}"
				done<"$file"
			else	title ""
				while $READ -r line;do
					tmpline="${line/\|/${PRINTABLE_PIPECHAR}}"
					tmplineb="${tmpline/\>/${PRINTABLE_GREATER}}"
					printe "${tmplineb/\</${PRINTABLE_LESSER}}"
				done
			fi
		done
	}
	log() { # [-?|-h|--help] [-f FILE=$script_log ] [-r "REASON=$script_name" ] "MESSAGE"
	# Purpose and result
	# additional description
	#
	# Variables
	#
	 	local RET thisFile DT REASON
		RET=1
		theLog="${script_log}"
		DT="$($DATE_TODAY)"
	#
	# Catch arguments
	#
	 	while :; do
	 		case "$1" in
	 		-h|-\?|--help)
	 			swarm.help.usage "${FUNCNAME[0]}"
	 			return 0
	 			;;
	 		-f)	# Use this file
	 			theLog="${2}"
				shift
	 			;;
	 		-r)	REASON="$2"
				shift
				;;
			*)	# No more options
	 			break
	 			;;
	 		esac
	 		shift
	 	done
		[[ -z "$theLog" ]] && { swarm.help.usage "${FUNCNAME[@]}" ; return 1 ; }
		[[ -z "$1" ]] && { swarm.help.usage "${FUNCNAME[@]}" ; return 1 ; }
	#
	# Functions
	#
		_add.line() {
			if ! ${TAIL:-tail} -n 1 "$theLog" | ${GREP:-\grep} -q " -------------------"
			then	${ECHO:-echo_} " -------------------" >> "$theLog"
			fi
		}
		_check.date() {
			${GREP:-grep} -q "$DT" "$theLog" && return 1
			[[ -f "$theLog" ]] && _add.line
			${ECHO:-echo_} "$DT" >> "$theLog"
		}
		_log.it() { # MSG
			${PRINTF:-printf} '$($DATE +'%T.%N') : ${REASON:-${script_name:-${0##*/}}} : %s\n' "$1"
		}
	#
	# Action
	#
		_check.date
		_log.it "$1"
	}
	asRoot() { # [-r FILE_FOR_RETCODE] "COMMAND" | "/path/to/file"
	# Executes passed command as root.
	# Returns with 1 if command has failed
		# Check wether we shall and/or can use sudo - or not
		if [[ -z "$useSudo" ]]
		then	[[ -n "$SUDO" ]] && \
				useSudo=${useSudo:-true} || \
				useSudo=${useSudo:-false}
			# Save for later
			cfg.set -v "$SWARM_USER_CONF" "useSudo" "$useSudo"
		fi
	# Variables
		local RETFILE RET
		RET=1
	# Check arguments, exit on missing
		[[ "$1" == "-r" ]] && { RETFILE="$2" ; shift 2 ; }
		[[ -z "$1" ]] && { swarm.show.usage "${FUNCNAME[1]}" ;return 1 ; }
	# Call it properly
		if $useSudo
		then	# Easy
			$SUDO "${@}"
			RET=$?
		else	# Hard
			if [[ -n "$SU" ]]
			then	$SU -c "${@}"
				RET=$?
			else	status 1 "$SWARM_MSG_SU_NFOUND"
				return $?
			fi
		fi
	# Save value if requested
		[[ -n "$RETFILE" ]] && $ECHO "$RET" > "$RETFILE"
	# Show and exit with RET code
		status $RET "$SWARM_MSG_WORD_EXECUTED:" "${*}"
	}
