#!/usr/bin/env bash
#
# 	Treeview reference
#
# swarm.sysinfo.*
#	.screen*	(name)
#		.available
#		.hz
#		.res
# 	.net		(name of active device, ex: wlp3s0)
#		.available
#		.ipx	(eXtern)
#		.ip
#		.ip6
#	.usb
#		.devices
#		.names
#	.cpu		(Nam
#		.core
#		.threads
#		.hz
#	.ram
#		.free
#		.used
#		.total
#	.chassis
#
#
swarm.sysinfo.cpu() { #
# Prints the CPU name, family, cores and mhz
#
	LC_ALL=C $AWK -F':' '/^model name/ {print $2}' /proc/cpuinfo | uniq | $SED -e 's/^[ \t]*//'
}
swarm.sysinfo.cpu.sockets() {
# Prints the amount of cpu sockets on the platine
#
	LC_ALL=C lscpu | $AWK -F ":" '/^Socket/ {print $2}'
}
swarm.sysinfo.cpu.cores() {
# Prints the amount of cores per cpu
#
	LC_ALL=C lscpu | $AWK -F ":" '/^Core/ {print $2}'
}
swarm.sysinfo.cpu.threads() {
# Prints the amount of threads per core
#
	LC_ALL=C lscpu | $AWK -F ":" '/^Thread/ {print $2}'
}
swarm.sysinfo.cpu.mhz() {
# Prints either the 'fix' mhz
# or the range of valid values.
	LC_ALL=C lscpu | $AWK -F ":" '/[Mm][hH]z/ {print $1" "$2}' | $SED s,"CPU ","",g
}
swarm.sysinfo.cpu.vendor() {
# Prints either the 'fix' mhz
# or the range of valid values.
	LC_ALL=C lscpu | $AWK -F ":" '/^Vendor/ {print $2}'
}
swarm.sysinfo.cpu.mips() { #
#
#
	LC_ALL=C lscpu | $AWK -F ":" '/^BogoMIPS/ {print $2}'
}
_swarm.sysinfo.list_input() {
#
#
	$AWK -F '="' '/Name/ {print $2}' "/proc/bus/input/devices" | $SED s,'"','',g # | \
	return
}
swarm.sysinfo.keyboard() {
# Prints connected keyboards
# 1 per line
	LC_ALL=C _swarm.sysinfo.list_input | $GREP -i -e key -e touchpad | $SORT -u
}
swarm.sysinfo.mouse() {
# Prints connected mice
# 1 per line
	LC_ALL=C _swarm.sysinfo.list_input | $GREP -i -e mouse -e track | $SORT -u
}
swarm.sysinfo.video() {
# Prints connected video
# 1 per line
	LC_ALL=C _swarm.sysinfo.list_input | $GREP -i -e video -e hdmi | $GREP -i -v sound | $SORT -u
}
swarm.sysinfo.video.path() {
	$GREP -A10 "$(swarm.sysinfo.video|$GREP -i video )" "/proc/bus/input/devices" | $GREP -i -v sound | $AWK -F "Sysfs=" '/Sysfs=/ {print $2}'
}
swarm.sysinfo.mic() {
# Prints connected microphones
# 1 per line
	LC_ALL=C _swarm.sysinfo.list_input | $GREP -i -e mic -e voice | $SORT -u
}
swarm.sysinfo.headphones() {
# Prints connected headphones
# 1 per line
	LC_ALL=C _swarm.sysinfo.list_input | $GREP -i -e headph | $SORT -u
}
swarm.sysinfo.screen() {
# Prints connected screens/monitor/display
# 1 per line
	if ! $isGUI
	then 	#{ $ECHO "$SWARM_MSG_PHRASE_SSHSESSION" ; return 1 ; }
		$PRINTF '%s\n' "$TERM"
		return 0
	fi
	# Check if the app is needed
	swarm.util.which xrandr >/dev/zero || swarm.os.install xrandr
	# the space makes the difference!
	LC_ALL=C xrandr | $AWK '/ connected/ {print $1}'
}
swarm.sysinfo.screen.available() {
# Prints connected screens/monitor/display
# 1 per line
	if ! $isGUI
	then	$isSSH && \
			$ECHO "$SWARM_MSG_PHRASE_SSHSESSION" || \
			$ECHO "$SWARM_MSG_PHRASE_TERMINAL"
		return 1
	fi
	# Check if the app is needed
	swarm.util.which xrandr >/dev/zero || swarm.os.install xrandr
	# the space makes the difference! (dis(-)connected)
	LC_ALL=C xrandr | $AWK '/connected/ {print $1}'
}
swarm.sysinfo.screen.res() {
# Prints the screens resolution
#
	if ! $isGUI
	then 	#{ $ECHO "$SWARM_MSG_PHRASE_SSHSESSION" ; return 1 ; }
		$PRINTF '%sx%s' "$COLUMNS" "$LINES"
		return 0
	fi
	# Check if the app is needed
	swarm.util.which xrandr >/dev/zero || swarm.os.install xrandr
	LC_ALL=C xrandr | $AWK '/\*/ {print $1}'
}
swarm.sysinfo.net() {
# Prints the name of the active internet device
# 1 per line
	swarm.util.which ip >/dev/zero || return 1
	LC_ALL=C ip addr | $GREP -v "NO-CARRIER" | $AWK -F ":" '/BROADCAST/ {print $2}'
}
swarm.sysinfo.net.available() {
# Prints available network device names
#
	$LS -1 /sys/class/net
	#swarm.util.which ip >/dev/zero || return 1
	#LC_ALL=C ip addr | $AWK -F ":" '/^[1-9]/ {print $2}'
}
swarm.sysinfo.net.ip() {
# Prints the IPv4 adress
#
	swarm.util.which ip >/dev/zero || return 1
	LC_ALL=C ip addr | $GREP inet | $GREP  -ve 127\.0 -ve " ::" -ve "inet6" | $AWK '{print $2}'
}
swarm.sysinfo.net.gateway() {
# Prints the IPv4 gateway
#
	swarm.util.which ip >/dev/zero || return 1
	LC_ALL=C ip addr | $GREP inet | $GREP  -ve 127\.0 -ve " ::" -ve "inet6" | $AWK '{print $4}'
}
swarm.sysinfo.net.ip6() {
# Prints the IPv6 adress
#
	swarm.util.which ip >/dev/zero || return 1
	LC_ALL=C ip addr | $GREP inet | $GREP  -ve 127\.0 -ve " ::" -ve "inet " | $AWK '{print $2}'
}
swarm.sysinfo.net.external_ip() { # [-v]
# Prints the external IPv4 adress
#
	local failsafe=0 data beVerbose=false ret=1
	[[ "$1" == "-v" ]] && { beVerbose=true ; shift ;}
	if swarm.util.which dig &>/dev/zero
	then	dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/zero
		return 0
	else	#echo -e "trying $CURLWGET\n\n" ; set -x
		case "${CURLWGET:-curl}" in
		curl)	echo curl icanhazip.com ; ret=$?		;;
		wget)	echo wget -qO - icanhazip.com ; ret=$?	;;
		esac
		#set +x
		[[ 0 -eq $ret ]] && return 0
	fi

	hostname -i && return 0
	#swarm.util.which ip >/dev/zero || return 1
	(ping -W 1 -c 1 "${HOSTNAME:-$(hostname)}" | $AWK '/\([0-9]/ {print $3}' | { $READ external_ip ; $ECHO "$external_ip"  > "$SWARM_TMP.exip";}  & )

	while $PS -a | $GREP -q ping #| $GREP -v $GREP
	do
		$beVerbose && bar -c "${SWARM_MSG_WORD_RETRIEVING^} ${SWARM_MSG_WORD_DATA}... ($failsafe)" >&2
		sleep 0.4
		((failsafe++)) ; [[ $failsafe -gt 200 ]] && return 1
	done
	data=$(<"$SWARM_TMP.exip")
	data="${data:1}"
	$beVerbose && \
		{ status -c 4 "${data:0:-1}" >&2 ; status -c 4 "${data:0:-1}" ; echo >/dev/zero ; } || \
		echo "${data:0:-1}"
}
swarm.sysinfo.device.vendor() {
# Prints the chassis vendor
#
	$CAT /sys/class/dmi/id/chassis_vendor 2>/dev/zero || $ECHO "$SWARM_MSG_WORD_UNKOWN"
}
swarm.sysinfo.device.name() {
# Prints the product name / description
#
	$CAT /sys/class/dmi/id/product_name 2>/dev/zero || $ECHO "$SWARM_MSG_WORD_UNKOWN"
}
swarm.sysinfo.device.type() {
# Prints the wether the system is VM or physical
#
	vserver=$(lscpu | $GREP Hypervisor | $WC -l) || return 1
	if [ $vserver -gt 0 ]
	then 	$ECHO "VM"
	else 	$ECHO "Physical"
	fi
}


_swarm.sysinfo.() {
# Prints the IPv6 adress
#
	swarm.util.which ip >/dev/zero || return 1
	LC_ALL=C
}
