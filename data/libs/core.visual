#!/usr/bin/env bash
#
# Prepare variables
#
#
# For easier code reusage, lets combine all math into a sub process
# Should help to speed things up a little more for the end user front ;)
# This seems useless... TODO remove or fix
#
if true
then
	unset ${!len*} my_test_var
	swarm.update.geometry() { #
		export DATE_TIME=$($DATE +'+%T')		# Time on the other hand is
		export clrCL="\e[2K"

		# Set basic values
		export BORDER_LEFT="${SWARM_THEME_DATA[border-left]}"
		BORDER_RIGHT="${SWARM_THEME_DATA[border-right]}"	# Do not export just yet
		export clrFRONT="${SWARM_THEME_DATA[color-front]}"
		export clrBACK="${SWARM_THEME_DATA[color-back]}"

		# Check if border-right was set:
		[ -z "$BORDER_RIGHT" ] && \
				for((i=${#BORDER_LEFT}-1;i>=0;i--)); do BORDER_RIGHT="$BORDER_RIGHT${BORDER_LEFT:$i:1}"; done
		export BORDER_RIGHT

		# Get some numbers
		export lenLeft="${#BORDER_LEFT}"
		export lenRight="${#BORDER_RIGHT}"
		export lenClrFont=${#clrFRONT}
		export lenClrBack=${#clrBACK}
		export identRight=$(( $lenRight + ${#clrCL}  ))

		# Pre-Calculate positions
		export numHALF=$(( $COLUMNS / 2 ))
		export numEND=$(( $numHALF * 2 ))
		export posEND="\33[${numEND}G"
		export posLEFT="\33[$(( $lenLeft + 2 ))G"

		# If user wants extended logs, he shall have it
		! $isRO && $doLogExt && init.log "$SWARM_MSG_INIT_PID_GEOMETRY: ${PPID:-$PID}"
	}
	export -f swarm.update.geometry
fi
if false
then
	# Sub shell
	(
		while ${PS:-\ps} ${PPID:-$PID} | ${GREP:-\grep} ${PPID:-$PID} >> /dev/zero
		do	# Ok, lets keep it simple
			swarm.update.geometry
			# Using 15 secs for fallback mode
			sleep ${SWARM_INTERVALL_GEOMETRY:-15}
		done
	) & >> /dev/zero
	SWARM_PID_USED="$SWARM_PID_USED $!"
fi
#
# Theme's
#
	swarm.theme.update() { # THEME_NAME
	# This loads the provided THEME_NAME
	#
		# This an assigned array containg the theme related data
		# Lets make sure each theme gets loaded into clear memory
		unset SWARM_THEME_DATA[@]	# Use terminal / console / vtr default settings as base
		# These are it's assingments
		swarm_list_theme_options="border-left border-right color-font color-back read select"
		# Lets start fresh
		declare -GA SWARM_THEME_DATA
		local ret=false

		# Always use the user themes first
		# in case someone wants to pseudo-overwrite the default themes
		for there in "$SWARM_USER_CONFIG/themes" "$SWARM_DIR_THEMES"
		do
			# check in each dir
			if [[ -d "$there" ]]
			then	if [[ -f "$there/$1" ]]
					then	source "$there/$1"
							ret=$?
					fi
			fi
		done

		# Check if something went wrong
		if [[ $ret != 0 ]]
		then	# The theme could not be Found
				# Lets fallback to default
				source "$SWARM_DIR_THEMES/default-blue"
				init.log.msg "$SWARM_MSG_INIT_THEME : $1"
		fi
		# Export the values now
		export SWARM_THEME_DATA #[@]
		# Now, return
		return $ret
	}
	swarm.theme.list() {
	# Lists all themes available
	# Includes SWARM_USER_CONFIG/themes and SWARM_DIR_THEMES alike
		local d f
		for d in "$SWARM_USER_CONFIG/themes/" "$SWARM_DIR_THEMES/"
		do
			# Check if path exists and handle each file for its own
			[[ -d "$d" ]] && \
				for f in $($LS "$d")
				do
					# Output only if it really is a file
					[[ -f "$f" ]] && $PRINTF '%s\n' "${f##*/}"
				done
		done
	}
	swarm.init.theme () { #
	# Initiate the theme for the first time
	# This is only a wrapper for the initial loading.
		swarm.theme.update ${SWARM_THEME:-default-blue}
	}
#
# Visual outputs - core essentials
#
	swarm.color.list() { #
	# Simply lists the color names that can be used in SWARM
	#
		if [[ -z "cb_black" ]]
		then	# The variables are empty
				# need to read from file
				local raw=$($GREP "cb_" ${SWARM_DIR_DATA}/core/colors.conf | $SED s,"cb_","",g ) #| $SED s,"="," ",g | $AWK ' $1'
				for r in $raw
				do
					$PRINTF '%s\n' "${r/=*}"
				done
		else	# Variables are available
				local tmp_str=""
				# Generate an end user optimized list
				for t in ${!cb_*}
				do	tmp_str="$tmp_str ${t/cb_}"
				done
				# Output
				$PRINTF '%s\n' $tmp_str
		fi
	}
	swarm.color.bg() {  # COLORNAME
	# Returns the color code of provided COLORNAME
	#
		local str=cb_${1:-blue}
		eval $PRINTF \$"${str}"
	}
	swarm.color.fg() {  # COLORNAME
	# Returns the color code of provided COLORNAME
	#
		local str=cf_${1:-white}
		eval $PRINTF \$"${str}"
	}
	swarm.print.goto() { # NUM
	# Returns the positioncode for passed NUM location
	# Returns number 0 if no argument is passed
		$PRINTF "\33[${1:-0}G"
	}
	swarm.print.bold() { # "STR"
	# Returns STR with wrapped code for BOLD
	#
		$PRINTF "\033[1m${1}\033[0m"
	}
	swarm.print.underline() { # "STR"
	# Returns STR with wrapped code for UNDERLINE
	#
		$PRINTF "\033[4m${1}\033[0m"
	}
	swarm.print.border() { # MODE
	# Prints basic border for all lines, this should only be executed if COLUMNS > 25
	# The calling function has to handle the NEWLINE required by 'printe' (-E)
		local MODE="" #name=""
		case "${1/-}" in
		e|p)	MODE="basic"	;;
		h)		MODE="header"	;;
		t)		MODE="title"	;;
		esac
		# Makes no sense to print visuals on such short lines
		[[ ${COLUMNS} -lt 25 ]] && return 1
#set -x
		# Set basic values
		local BORDER_LEFT="${SWARM_THEME_DATA[border-left]}" BORDER_RIGHT="${SWARM_THEME_DATA[border-right]}"
		local clrFRONT="${SWARM_THEME_DATA[color-front]}" clrBACK="${SWARM_THEME_DATA[color-back]}"
		local clrCL="\e[2K"
		c_front=$(swarm.color.fg ${SWARM_THEME_DATA[color-front]})
		c_back=$(swarm.color.bg ${SWARM_THEME_DATA[color-back]})

		# Check if border-right was set:
		[ -z "$BORDER_RIGHT" ] && \
			for((i=${#BORDER_LEFT}-1;i>=0;i--)); do BORDER_RIGHT="$BORDER_RIGHT${BORDER_LEFT:$i:1}"; done

		# Now prepare the seperate handling
		PRINT_RIGHT_OUT="$c_reset"
		case "$MODE" in
			"basic")
					PRINT_LEFT_IN="$c_reset"
					PRINT_LEFT_OUT="${clrCL}${c_front}${c_back}"
					PRINT_RIGHT_IN="${c_front}${c_back}"
					pos_cor_num=0
					;;
			"header")
					local filler_num=$(( $(( $COLUMNS / 2 * 2)) - $(( ${#BORDER_RIGHT} * 2 )) + 2 ))
					local filler_str=$($PRINTF "%*s" ${filler_num})
					PRINT_LEFT_IN="$filler_str" #$c_reset"
					PRINT_LEFT_OUT="${clrCL}${c_front}${c_back}"
					PRINT_RIGHT_IN="" #${c_front}${c_back}"
					pos_cor_num=0
					;;
			"title")
					local filler_num=$(( $(( $COLUMNS / 2 * 2)) - $(( ${#BORDER_RIGHT} * 2 )) + 2 ))
					local filler_str=$($PRINTF "%*s" ${filler_num})
					PRINT_LEFT_IN="${c_invert}$filler_str" #$c_reset"
					PRINT_LEFT_OUT="${clrCL}${c_front}${c_back}"
					PRINT_RIGHT_IN="${c_reset}${c_front}${c_back}"
					pos_cor_num=0
					;;
		esac

		# Get some numbers
		local lenLeft="${#BORDER_LEFT}"
		local lenRight="${#BORDER_RIGHT}"
		local lenClrFont=${#c_front}
		local lenClrBack=${#c_back}

	#	local identRight=$(( $lenRight + ${#clrCL}  ))
		local posLEFT="\33[$(( ${#BORDER_LEFT} - 2 ))G"
		local posRIGHT="\33[$(( $(( $COLUMNS / 2 * 2 )) - $lenRight - $pos_cor_num ))G"
		local posEND="\33[$(( $(( $COLUMNS / 2 * 2 )) ))G"

#set +x
		# Well, left aligned it works. isnt too hard
		#printf "\r${clrCL}${BORDER_LEFT} " >&2		# ORG
		$PRINTF "\r${PRINT_LEFT_OUT}${posLEFT}${BORDER_LEFT}${PRINT_LEFT_IN}" #>&2

		# The right side is much more challenging
		#printf "${posRIGHT}${BORDER_RIGHT}" >&2
		$PRINTF "${posRIGHT}${PRINT_RIGHT_IN}${BORDER_RIGHT}${PRINT_RIGHT_OUT}${c_reset}" >&2
		$PRINTF "${posEND}"
	}
	swarm.print.text() { # MODE [ LEFT CENTER RIGHT]
	# This simply puts the text
	# according to MODE
		local fix_title=0
		local fix_header_r=0
		case ${1/-} in
			t)	MODE=title
				fix_title=16	;;
			h)	MODE=header
				fix_header_r=4	;;
			*)	MODE=basic	;;
		esac
		shift

		# Check if it is too short, if so, print fallback mode and return
		[[ ${COLUMNS} -lt 25 ]] && \
				$PRINTF "%s\n" "${@}" && \
				return 1

		# Make sure values are udpated
		swarm.update.geometry

		# Get the actual string
		local evalLeft=$($PRINTF "$1")
		local evalMiddle=$($PRINTF "$2")
		local evalRight=$($PRINTF "$3")

		# Retrieve their length
		local lenEvalLeft=${#evalLeft}
		local lenEvalMiddle=${#evalMiddle}
		local lenEvalRight=${#evalRight}

		# Output
		case ${#@} in
		0)	# Nothing to print
			$PRINTF "${posLEFT}"
			;;
		1)	# Just left oriented
			$PRINTF "${posLEFT}$1"
			#return
			;;
		2)	# 2nd arg is right oriented
			$PRINTF "${posLEFT}$1"
			local posRIGHT="\33[$(( $numEND - $lenMiddle - ${lenEvalMiddle} - 1 + $fix_header_r ))G"
			$PRINTF "${posRIGHT}$2"
			#return
			;;
		3)	# Default handling
			local posMIDDLE="\33[$(( $numHALF - $(( ${#2} / 2 ))  + $fix_title ))G"
			local posRIGHT="\33[$(( $numEND - $lenRight - ${lenEvalRight} - 1 + $fix_header_r ))G"
			$PRINTF "${posLEFT}$1"
			$PRINTF "${posMIDDLE}$2"
			$PRINTF "${posRIGHT}$3"
			;;
		esac

		$PRINTF "${posEND}"
	}
	swarm.str.status() { # ERRNUM
	# Returns the string to be printed according to ERRNUM
	# This already takes care of terminal only or GUI visuals
		#
		# Colors
		#
			local R="${SWARM_COLOR_RESET}"
			local r="${SWARM_COLOR_FG_RED}"
			local y="${SWARM_COLOR_FG_YELLOW}"
			local p="${SWARM_COLOR_FG_PURPLE}"
			local g="${SWARM_COLOR_FG_GREEN}"
			local b="${SWARM_FONT_BOLD}"
			local S="${SWARM_FONT_STROKE}"
		#
		# Check wether it is an X session
		#
		if [[ -n "${XDG_CURRENT_DESKTOP:-${DESKTOP_SESSION:-$XAUTHORITY}}" ]]
		then 	# Yes it is
				case "$1" in
					"0")	value=" ${g}${b}✓${R}  "
							;;
					"1")	value=" ${r}${b}✗${R}  "
							;;
					"2")	value=" ${y}${b}∞${R}  "
							;;
					"3")	value=" ${p}${b}≣${R}  "
							;;
					"4")	value=" »  "
							;;
					"5")	value=" >  "
							;;
					"6")	value=" <  "
							;;
					"7")	value=" ${r}${b}✗${R}  "
							;;
					"10")	value=" ${g}${b}◆${R}  "
							;;
					"11")	value=" ${r}${b}◇${R}  "
							;;
					"99")	value=" ⅈⅈ "
							;;
					"111")	value=${STATUS_TEXT[111]}""
							;;
					"127")	value=" ${r}${b}✗${R}  "
							;;
					"130")	value=" ${r}${b}✗${R}  "
							;;
				esac
		else
				# It's TTY
				case "$1" in
					"0")	value=""
							;;
					"1")	value=""
							;;
					"2")	value=""
							;;
					"3")	value=""
							;;
					"4")	value=""
							;;
					"5")	value=""
							;;
					"6")	value=""
							;;
					"7")	value=""
							;;
					"10")	value=""
							;;
					"11")	value=""
							;;
					"99")	value=""
							;;
					"111")	value=""
							;;
					"127")	value=""
							;;
					"130")	value=""
							;;
				esac
				value="${STATUS_TEXT[$1]}"
		fi
		$PRINTF "[ ${value} ]"
		## TODO OLD ----------------------------- OLD
		return

		#
		#	Displayable 'Status text'
		#
			# How to reckognize Wayland?
			if [ -n "${XDG_CURRENT_DESKTOP:-${DESKTOP_SESSION:-$XAUTHORITY}}" ]
			then # Prepare GUI values				# ≡≣❑☑☒☐⚠✓✗❑ⅈ×∘∙◆◇√✘

				SWARM_DONE="[  ]"	# This brings the cleanest result
				SWARM_FAIL="[  ]"
				SWARM_TODO="[  ]"
				SWARM_WORK="[  ]"

				# What colos would apply here?
				SWARM_SKIP="[  ]"
				SWARM_NEXT="[  ]"
				SWARM_BACK="[  ]"
				SWARM_CANC="$SWARM_FAIL"

				SWARM_ON="[  ]"
				SWARM_OFF="[  ]"

				SWARM_INFO="[  ]"
				SWARM_HELP="[ HELP ]"

			else	#
				# Prepare TERMINAL values
				#
				SWARM_DONE="[ ${g}${b}${STATUS_TEXT[0]}${R} ]"
				SWARM_FAIL="[ ${r}${b}${STATUS_TEXT[1]}${R} ]"

				SWARM_WORK="[ ${y}${b}${STATUS_TEXT[2]}${R} ]"
				SWARM_TODO="[ ${p}${b}${STATUS_TEXT[3]}${R} ]"

				# What colos would apply here? same as above...
				SWARM_SKIP="[ ${STATUS_TEXT[4]} ]"
				SWARM_NEXT="[ ${STATUS_TEXT[5]} ]"
				SWARM_BACK="[ ${STATUS_TEXT[6]} ]"
				SWARM_CANC="[ ${STATUS_TEXT[7]} ]"

				SWARM_ON="[ ${g}${b}${STATUS_TEXT[10]}${R} ]"
				SWARM_OFF="[ ${r}${b}${STATUS_TEXT[11]}${R} ]"

				SWARM_INFO="[ ${STATUS_TEXT[111]} ]"
				SWARM_HELP="[ ${STATUS_TEXT[99]} ]"

			fi
			SWARM_NFOUND="$SWARM_FAIL"
	}
#
# Not all terminals support WIDTH and LINES....
#
	if [[ "x" == "x$LINES" ]] || [[ "x" == "x$COLUMNS" ]]
	then	# Seems this terminal doesnt provide these variables...
			# Since it's 2020, lets do multi tasking this in the background!
		(
			while ${PS:-\ps} ${PPID:-$PID} | ${GREP:-\grep} ${PPID:-$PID} >> /dev/zero
			do
				export COLUMNS="$(eval $TPUT cols)"
				export LINES="$(eval $TPUT lines)"
				# If user wants extended logs, he shall have it
				! $isRO && $doLogExt && init.log "$SWARM_MSG_INIT_PID_GEOMETRY: ${PPID:-$PID}"
				# Using 15 secs for fallback mode
				sleep ${SWARM_INTERVALL_GEOMETRY:-15}
			done
		) & >> /dev/zero
		# Just in case..
		# We dont want 100 background process running...
		SWARM_PID_THEME="$SWARM_PID_THEME $!"
	fi
#
# And for easier code reusage, lets combine all math into a sub process
# Should help to speed things up a little more ;)
#
