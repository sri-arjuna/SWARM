#!/usr/bin/env bash
#
# Prepare functions
# that are supposed to be used by 'enduser' script authors
# Stuff like: yeno, pick, printe, header, title and 'all the rest'
#
#
# Visual outputs - 'End user' stuff
#
	header() { # LEFT CENTER RIGHT
	# This prints a full line in blue (default-back), with white (default-front) text
	# TODO long string adjustments TODO, uses script_{name,version} before it uses its SWARM counterparts
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		swarm.print.border -h
		case "$1" in
		"--default")
			shift
			#local today=`$DATE_TODAY`
			#local time=`$DATE_TIME`
			swarm.print.text -h \
				"${c_front}${c_back}${script_name:-SWARM} ${script_version:-${SWARM[VERSION]}-${SWARM[BUILD]}}" \
				" " \
				"$($PRINTF '%s ' ${@}) | `$DATE_TODAY` / `$DATE_TIME`${c_reset}"
			#swarm.print.text -h \
			#	"${c_front}${c_back}${script_name:-SWARM} ${script_version:-${SWARM[VERSION]}-${SWARM[BUILD]}}" \
			#	" " \
			#	"$($PRINTF '%s ' ${@}) | ${today} / ${time}${c_reset}"
			;;
		*)
			swarm.print.text -h "${c_front}${c_back}$1" "$2" "$3${c_reset}"
			;;
		esac
		$PRINTF "$posEND\n"
	}
	title() { # Text
	# This prints a single centered string on a line
	# It has blue borders and fills the inner line with white (Default-{front,back})
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		swarm.print.border -t
		output="$1"
		#output=$(swarm.print.underline "$output")
		output=$(swarm.print.bold "$output")
		swarm.print.text -t "" "${c_front}${c_back}${c_invert}${output}${c_reset}" ""
		$PRINTF "$posEND\n"
	}
	printe() { # STR1 STR2 STR3
	# Simply prints the strings as passed, it requires 3 strings to use the center
	# For piping, it expects 3 lines, each representing 1 variable
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#set -x
		local MODE="none"
		# Get args
		case "$1" in
		"-1"|"-2")	MODE="${1/-}"
				shift
				;;
		*)		MODE="normal"
				;;
		esac
		# Get arg number if not forced yet
		[[ "normal" == "$MODE" ]] && [[ "-" != "$1" ]] && [[ "--" != "$1" ]] && MODE=${#@}
		# Get pipe?
		case "$1" in
		"--"|"-")
			case "$MODE" in
				"2")
					# Read pipe, expect 2 lines
					while read LEFT
					do
						read RIGHT
						printe "$LEFT" "" "$RIGHT"
					done
					return
					;;
				"1")
					# Read pipe, expect 1 lines
					while read LEFT
					do
						printe "$LEFT"
					done
					return
					;;
				*)
					# Read pipe, expect 3 lines (default)
					while read LEFT
					do
						read CENTER; read RIGHT
						printe "$LEFT" "$CENTER" "$RIGHT"
					done
					return
					;;
				esac
			;;
		esac
		#set +x
		case "$MODE" in
			"0")
				swarm.print.border -e
				swarm.print.text -e "" "" ""
				;;
			"1")
				swarm.print.border -e
				swarm.print.text -e "$1" "" ""
				;;
			"2")
				swarm.print.border -e
				swarm.print.text -e "$1" "" "$2"
				;;
			"3")
				swarm.print.border -e
				swarm.print.text -e "$1" "$2" "$3"
				;;
		esac
		$PRINTF "$posEND\n"
	}
	printl() { # STR1 STR2 STR3
	# Simply prints the strings as passed, stays on the same line
	# It requires 3 strings to use the center
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		case "$1" in
		"--"|"-")
				# Read pipe, expect 3 lines
				read LEFT; read CENTER; read RIGHT
				printe "$LEFT" "$CENTER" "$RIGHT"
				return
				;;
		esac
		swarm.print.border -p
		swarm.print.text -p "$1" "$2" "$3"
	}
#
# Visual outputs - 'End user' stuff - Core Convenience
#
	yesno() { # "What question?"
	# Ask a yes/no question, returns 0/true for yes and 1/false for no
	# y/n are taken from language file and are used in code
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		# Check if 'yesno' is empty, if so, fill with fallback values
		case "$1" in
		"--help"|"-h")
			swarm.help.screen "${SWARM_MSG_HELP_YESNO}"
			return 99
			;;
		esac
		[[ -z "${SWARM_MSG_YESNO_YES}${SWARM_MSG_YESNO_NO}" ]] && \
			SWARM_MSG_YESNO_YES="+" && \
			SWARM_MSG_YESNO_NO="-"

		swarm.print.border -e
		# Print the text
		$PRINTF "$(swarm.print.goto $(( ${#SWARM_THEME_DATA[border-left]} + 2  )))$1 (${SWARM_MSG_YESNO_YES:0:1}${SWARM_MSG_YESNO_NO:0:1})"
		# Move the cursor
		$PRINTF "$(swarm.print.goto $(( $COLUMNS / 2 * 2 - ${#SWARM_THEME_DATA[border-left]} - 2  )))"
		read -n1 answer
		$PRINTF "$posEND\n"

		case "$answer" in
		"+"|"${SWARM_MSG_YESNO_YES:0:1}")
				return 0
				;;
		"-"|"${SWARM_MSG_YESNO_NO:0:1}")
				return 1
				;;
		*)		return 1
				;;
		esac
	}
	status() { # $? ["Text Left"] ["Text Center"]
	# Prints text and exit with passed return code
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		unset RET TXT1 TXT2
		# Check for minimal arguments
		[[ -z "$1" ]] && \
			$PRINTF '%s\n' "$SWARM_MSG_STATUS_ARG_INVALID" && \
			return 99
		local RET="$1"
		local value="$(swarm.str.status $RET)"

		swarm.print.border -e >&2
		swarm.print.text -e "$2" "$3" "" >&1

		# Adjust fixer according to X or TTY
		[[ -n "${XDG_CURRENT_DESKTOP:-${DESKTOP_SESSION:-$XAUTHORITY}}" ]] && \
			gui_fixer="7" || gui_fixer=7

		$PRINTF "$(swarm.print.goto $(( ${COLUMNS:-$(${TPUT:-\tput} cols)} / 2 * 2 - ${#SWARM_THEME_DATA[border-left]} - 2 - $gui_fixer  )))"  # Sehe keinen unterschied zw. 4 bis 7
		#$PRINTF "$(swarm.print.goto $(( $COLUMNS / 2 * 2 - ${#SWARM_THEME_DATA[border-left]} - 2 - $gui_fixer  )))"  # Sehe keinen unterschied zw. 4 bis 7
		$PRINTF "$value" >&1

		$PRINTF "$posEND\n"
		return $RET
	}
	swarm.str.bool2str() { # [options] $?
	# Returns a string from a BOOL input
	#
		swarm.protect "$FUNCNAME" "${@}" && exit 1
		#
		# Defaults
		#
			local caps #=false
			local CAPS #=false
			local mode #="yes"
			local out=""
			echo " ---------- $@ ----------- "
		#
		# Catching Arguments
		#
			# A ':' after a char indicates that this option requires an argument
			# Get access to the passed value of the argument by using $OPTARG
			while getopts "cCdoty" opt
			do
			 	case ${opt} in
				"c")	caps=true
						shift	;;
				"C")	CAPS=true
						shift	;;
				"d")	mode="done"
						shift
						echo " -- SHOULD -- get here"	;;
				"t")	mode="true"
						shift	;;
				"y")	mode="yes"
						shift	;;
				"o")	mode="on"
						shift	;;
			#	*)	echo opt $opt ; exit 99	;;
				esac
			done
			shift $(($OPTIND - 1))
		#
		# Display & Action
		# This also handles translations
		#
			case "${mode}" in
			"done")	case "$1" in
				0)	out="$SWARM_MSG_BOOL2STR_DONE"	;;
				1)	out="$SWARM_MSG_BOOL2STR_FAIL"	;;
				esac
				;;
			"true")	case "$1" in
				0)	out="$SWARM_MSG_BOOL2STR_TRUE"	;;
				1)	out="$SWARM_MSG_BOOL2STR_FALSE"	;;
				esac
				;;
			"on")	case "$1" in
				0)	out="$SWARM_MSG_BOOL2STR_ON"	;;
				1)	out="$SWARM_MSG_BOOL2STR_OFF"	;;
				esac
				;;
			"yes"|*)	case "$1" in
				0)	out="$SWARM_MSG_BOOL2STR_YES"	;;
				1)	out="$SWARM_MSG_BOOL2STR_NO"	;;
				esac
				;;
			esac

			# Show the output
			if ${CAPS:-false}
			then	$PRINTF "${out^^}"
			elif ${caps:-false}
			then	$PRINTF "${out^}"
			else	$PRINTF "$out"
			fi
	}
	swarm.str.num2char() { # NUM
	# Returns a letter string: a-z
	# Or: aa-az ba-bz, etc
		num="$1"
		out=""
		# Quoting these echo's will break the output
		[ "$num" -gt 700 ] && \
			list=( $(builtin echo {a..z} {a..z}{a..z} {a..z}{a..z}{a..z} ))	|| \
			list=( $(builtin echo {a..z} {a..z}{a..z} )) 	# Be fast for letters in range..
		out="${list[$num]}"
		$PRINTF '%s\n' "$out"
	}
	swarm.str.num2roman() { # NUM
	# Returns NUM in roman letters
	#
		input="$1"	# input num
		output=""	# Clear output string
		len="${#input}"	# Initial length to count down
		U="\033[4m"	# Underscore, multiplies with 1000
		R="\033[0m"	# Resets the underscore
		roman_val() { # NUM one five ten
		# This sub does the basic 'roman' algorithm
		#
			N="$1"
			one="$2"
			five="$3"
			ten="$4"
			out=""
			case "$N" in
			0)	out+=""	;;
			[123])	while [ "$N" -gt 0 ]
				do	out+="$one"
					N="$(($N-1))"
				done
				;;
			4)	out+="$one$five"	;;
			5)	out+="$five"	;;
			[678])	out+="$five"
				N="$(($N-5))"
				while [ "$N" -gt 0 ]
				do	out+="$one"
					N=$(($N-1))
				done
				;;
			9)	while [ "$N" -lt 10 ]
				do	out+="$one"
					N="$(($N+1))"
				done
				out+="$ten"
				;;
			esac
			echo "$out"
		}
		while [ "$len" -gt 0  ]
		do	# There are letters to add
			num="${input:0:1}"
			# Do action according position
			case "$len" in
			1)	output+="$(roman_val $num I V X)"	;;
			2)	output+="$(roman_val $num X L C)"	;;
			3)	output+="$(roman_val $num C D M)"	;;
			4)	output+="$(roman_val $num M ${U}V${R} ${U}X${R})"	;;
			5)	output+="$(roman_val $num ${U}X${R} ${U}L${R} ${U}C${R})"	;;
			*)	# Count it up
				Tone="CI\)"
				Tfive="I\)"
				Tten="CCI\)\)"
				DEPTH="$(( $len - 3 ))"	# 1 = 1000 = initial template
				while [ "$DEPTH" -gt 1 ]
				do	Tone="C$Tone)"
					Tfive="C$Tfive)"
					Tten="C$Tten)"
					DEPTH="$(($DEPTH-1))"
				done
				output+="$(roman_val $num $Tone $Tfive $Tten  )"
				;;
			esac
			input="${input:1}" ; len="${#input}"
		done
		$PRINTF "$output"
	}
	printlist() { # [options] $LIST or ${ARRAYS[@]}
	# Prints up to 3 'indexed'/numbered entries per row
	# Options -12arn ; 1 or 2 rows (instead of 3=default), alpha, roman, num=default
		#
		# Variable defaults (options)
		#
			local MODE=none
			local SEP=""
			local ROWS=3
			local as_menu=false
		#
		# Catch arguments
		#
			for opt in "${@}"
			do 	[[ "-" == "${opt:0:1}" ]] && \
				case "${opt/-}" in
				"1" | "2" | "3")
					ROWS="${opt/-}"
					shift
					;;
				"0")	as_menu=true
					shift
					;;
				"a")	MODE=alpha
					SEP=") "
					shift
					;;
				"r")	MODE=roman
					SEP=". "
					shift
					;;
				"n")	MODE=num
					SEP=") "
					shift
					;;
				esac
			done
			[ -z "$1" ] && \
				while IFS= read -r ARG
				do	set -- "$@" "$ARG"
				done
			ARGS=( "${@}")
			# Update geometry
			swarm.update.geometry
		#
		# Action
		#
			unset OUT[@]
			OUT[0]=""
			local shown=false
			local MAX="$(( $ROWS - 1 ))"
			local CUR=0
			local DONE=0
			local count=""
			for OPT in "${ARGS[@]}"
			do	$as_menu || DONE="$(( $DONE + 1))"
				# Do the visible counter
				case "$MODE" in
				num)	count="$DONE"
					;;
				alpha)	count="$(swarm.str.num2char $(( $DONE - 1 )) )"
					;;
				roman)	count="$(swarm.str.num2roman $DONE)"
					;;
				esac

				# Add the string to array, or print array
				if [ "$CUR" -le "$MAX" ]
				then	len=0
					for O in "${OUT[@]}";do len=$[ $len + ${#O} ];done
					sum="$(( $len + 2  + ( ${#BORDER_LEFT} * 2 ) ))"

					if [ "$sum" -lt "$COLUMNS" ]
					then	OUT["$CUR"]="${count}${SEP}${OPT}"
						shown=false
						CUR="$(( $CUR + 1 ))"
					else	printe  "${OUT[@]}" >&2
						CUR=0 && unset OUT[@]
						[ -z "$OPT" ] && shown=true
						OUT["$CUR"]="${count}${SEP}${OPT}"
						CUR="$(( $CUR + 1 ))"
					fi
				else 	printe  "${OUT[@]}" >&2
					CUR=0 && unset OUT[@]
					[ -z "$OPT" ] && shown=true
					OUT["$CUR"]="${count}${SEP}$OPT"
					CUR="$(( $CUR + 1 ))"
				fi
				$as_menu && DONE="$(( $DONE + 1))"
			done
		#
		# Display
		#
			! $shown && printe  "${OUT[@]}" >&2
			return 0
	}
	pick() { # [-1 -2 -a -m] $LIST or ${ARRAYS[@]}
	# Select an item of a LIST or an ARRAY
	# Returns the value
		#
		# Variables
		#
			local counter=0
			local AUTO=false
			local ROWS="3"
			local as_menu=false
		#
		# Catch arguments
		#
			for opt in "${@}"
			do	if [[ "-" == "${opt:0:1}" ]] 
				then	case "${opt/-}" in
					1|2|3)	ROWS="${opt/-}"
						shift
						;;
					"a")	AUTO=true
						shift
						;;
					"m")	trap "return 130" INT ABRT KILL
						as_menu=true
						shift
						;;
					"-")	wasPipe=true
						;;
					esac
				fi
			done
			# Can not be set earlier because of possible options
			# Which state wether it is 'as menu' or default
			$as_menu && \
				local ARGS=( "${SWARM_MSG_PICK_BACK}" "${@}" ) || \
				local ARGS=("${@}")
		#
		# Pipe handling
		# It's different when working with 'read'
		#
			#wasPipe=false
			#[ -z "$1" ] && \
			#	while IFS= read -r ARG
			#	do	set -- "$@" "$ARG" && wasPipe=true
			#	done
		# Handle auto-pick (only 1 option)
			"$AUTO" && \
				[ "$#" -eq 1 ] && \
				$PRINTF '%s\n' "$ARGS" >&1 && \
				return 4
		# Show the items to pick from
			#set +x
			$as_menu && \
				printlist -n -$ROWS -0 ${ARGS[@]} || \
				printlist -n -$ROWS "${ARGS[@]}"
			#set -x
		# Set dynamic values
			# Amount of arguments
			local pick_count=${#ARGS[@]}
			# Character length of the amount
			local pick_len=${#pick_count}
			#Special handling
			local invalid=true
			local NUM=""
			local POS="$(swarm.print.goto $(( $identRight + 2 )))${SWARM_THEME_DATA[read]} "
			$as_menu && \
				local min=0 || \
				local min=1
		#
		# Visuals
		#
		while $invalid
		do
			# Except the best, prepare for the worst
			#invalid=false
		# Print the input line:
			swarm.print.border
			$PRINTF "$POS      $POS" >&2
		# Read the input 
			builtin read -n $pick_len NUM
		# Catch invalid inputs
			# Keep reading if NUM is empty
			[[ -z "$NUM" ]] && continue
			#set -x
			# Check for arrow keys
			#set +x
			# Check if NUM is numeric
			if [[ ${#NUM} -ge 0 ]] >/dev/null
			then
				# If it's exactly 0, it's BACK
				[[ ${#NUM} -eq 0 ]] && $ECHO "${ARGS[$NUM]}" && return
				# It's not zero but some other numeric input
				
				# Keep reading if it is not greater than 'min'-imum
				[[ ${NUM} -ge $min ]] &2>/dev/zero || continue
				# Keep reading if it is greater than pick_count
				[[ $NUM -gt $pick_count ]] && continue
				
				# Exit the loop
				invalid=false
			else
				# It's not a number, catch other cases
				continue
			# Actualy, all checks below are (can be) left out....	
				# Keep reading if NUM contains letters
				# Using builtin echo for speed and less disk usage
				builtin echo "$NUM" | $GREP -E -q "[a-zA-Z]"  && continue	# &2>/dev/zero
				# Check for arrow keys
				[[ "$NUM" =~ ^\[\[ ]] && continue
				#builtin echo "$NUM" | $GREP -E -q "^\[\[" && continue
				[[ "$NUM" =~ '^[[' ]] && continue
				# Keep reading if NUM is longer than $pick_len
				# ?? This SHOULD catch arrow-keys in most real usage cases
				[[ ${#NUM} -gt ${pick_len} ]] &2>/dev/zero && continue
			fi
		done
		# Make 'nice to have' line break when read automatically stops reading
		if [ "${#NUM}" -eq "${#len}" ] 
		then	# Only print newline character if the entered number as the longest number
			# But not sub zero
			[ "${NUM}" -ne -1 ] && $PRINTF "\n" >&2
		else	# Since arrays are 0 indexed, 10 becomes 9 and need special treatment
			[ "${NUM}" -eq 9 ] && $PRINTF "\n" >&2
		fi
		$as_menu || NUM=$(( $NUM - 1))
		
		# Prepare output
		$ECHO "${ARGS[$NUM]}"
		unset opt
	}
